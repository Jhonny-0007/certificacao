3.1 - Exercícios

Exercício 1:

class Test {
    public static void main(String[] args) {
        for (int i = 0; i < 20; i++) {
            System.out.println(i);
        }
        System.out.println(i);
    }
}

a - Erro de compilação.
b - Compila e roda, imprimindo de 0 até 19 e depois 19.
c - Compila e roda, imprimindo de 0 até 19, depois ocorre um erro de execução.



Exercício 2:

class Test {
    public static void main(String[] args) {
        for (int i = 0; i < 20; i++)
            System.out.println(i);
        System.out.println(i);
    }
}

a - Erro de compilação.
b - Compila e roda, imprimindo de 0 até 19 e depois 19.
c - Compila e roda, imprimindo de 0 até 19, depois 19, depois finished.
d - Compila e roda, imprimindo de 0 até 19, depois ocorre um erro de execução.



Exercício 3:

class Test {
    public static void main(String[] args) {
        for (int i = 0; i < 20; i++) {
            System.out.println(i);
        }
        int i = 15;
        System.out.println(i);
    }
}

a - Erro de compilação na linha 6. A variável i não pode ser redeclarada.
b - Erro de compilação na linha 7. A variável i é ambígua.
c - Compila e roda, imprimindo de 0 até 19 e depois 15.
d - Compila e roda, imprimindo de 0 até 19, depois ocorre um erro de execução na linha 6.
e - Compila e roda, imprimindo de 0 até 19 e depois 19 novamente.



Exercício 4:

class Test {
    static int x = 15;
    public static void main(String[] x) {
        x = 200;
        System.out.println(x);
    }
}

a - O código compila e roda, imprimindo 200.
b - O código compila e roda, imprimindo 15.
c - O código não compila.
d - O código compila mas dá erro em execução.



Exercício 5:

class Test {
    static int i = 3;
    public static void main(String[] a) {
        for (new Test().i = 10; new Test().i < 100; new Test().i++) {
            System.out.println(i);
        }
    }
}

a - Não compila a linha 4.
b - Não compila a linha 5.
c - Compila e imprime 100 vezes o número 3.
d - Compila e imprime os números de 10 até 99.




3.2 - Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir
sem nenhum parâmetro na linha de comando, como java D:

package a.b.c;

import java.util.*;

class D {
    public static void main(String[] args) {
        ArrayList<String> existing = new ArrayList<String>();

        for (String arg : args) {
            if (new E().exists(arg))
                existing.add(arg);
        }
    }
}

import java.io.*;

class E {
    public boolean exists(String name) {
        File f = new File(name);
        return f.exists();
    }
}

a) O arquivo não compila.
b) O arquivo compila mas dá erro de execução pois o array é nulo.
c) O arquivo compila mas dá erro de execução pois o array tem tamanho zero.
d) Roda e imprime false.
e) Roda e imprime true.
f) Roda e não imprime nada.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class Test {
    int Test = 305;

    void Test() {
        System.out.println(Test);
    }

    public static void main(String[] args) {
        new Test();
    }
}

a) O código não compila: erros nas linhas 2, 4, 5 e 6.
b) O código não compila: erro na linha 5.
c) O código não compila: erros nas linhas 2, 4 e 6.
d) O código compila e, ao rodar, imprime 305.
e) O código compila e não imprime nada.
f) O código compila e, ao rodar, imprime uma linha em branco.


3 - Escolha a opção adequada ao tentar compilar o arquivo a seguir:

package br.com.teste;

import java.util.ArrayList;

a) Erro na linha 1: definimos o pacote mas nenhum tipo.
b) Erro na linha 3: importamos algo desnecessário ao arquivo.
c) Compila sem erros.

4 - Escolha a opção adequada ao tentar compilar o arquivo A.java:

class A implements B {
}

public interface B {
}

class C extends A {
}

class D extends A, implements B {
}

a) Não compila: erro na linha 7.
b) Não compila: erro na linha 3.
c) Não compila: erro na linha 1, 3 e 7.
d) Não compila: erro na linha 3 e 7.
e) Compila.


3.3 Exercícios

1 - Qual é uma assinatura válida do método main para executar um programa Java?
a) public static void main(String... args)
b) public static int main(String[] args)
c) public static Void main(String []args)
d) protected static void main(String[] args)
e) public static void main(int argc, String[] args)

2 - Escolha a opção adequada para compilar e rodar o arquivo A.java, existente no diretório b:

package b;
class A {
    public static void main(String[] args) {
        System.out.println("running");
    }
}

a) javac A e java A
b) javac A.java e java A
c) javac b/A.java e java A
d) javac b/A.java e java b.A
e) javac b.A.java e java b.A
f) javac b.A e java b.A

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        System.out.println(args); // A
        System.out.println(args.length); // B
        System.out.println(args[0]); // C
    }
}

a) Não compila: array não possui membro length.
b) Não compila: o método println não consegue imprimir um array.
c) Ao rodar sem argumentos, ocorre uma ArrayIndexOutOfBoundsException na linha C.
d) Ao rodar sem argumentos, ocorre uma NullPointerException na linha B.
e) Ao rodar sem argumentos, são impressos os valores “1” e “A”.
f) Ao rodar com o argumento “certification”, são impressos os valores “2” e “A”.

4 - Escolha a opção adequada para rodar a classe A.java presente no diretório b, 
que foi compactado em um arquivo chamado program.jar, sendo que não existe nenhum arquivo de manifesto:

package b;
class A {
    public static void main(String[] args) {
        System.out.println(args[0]);
    }
}

a) java jar program.jar
b) java jar program.jar b.A
c) java -jar program.jar
d) java -jar program.jar b.A
e) java -cp program.jar
f) java -cp program.jar b.A

5 - Escolha a opção adequada para compilar a classe A.java, definida como no pacote b presente no diretório b, 
e adicionar também o arquivo program.jar na busca de classes durante a compilação. Lembre-se que . significa 
o diretório atual.

a) javac -cp b.A.java -cp program.jar
b) javac -jar program.jar b.A.java
c) javac -cp program.jar:b A.java
d) javac -cp program.jar:. b.A.java
e) javac -cp . -cp program.jar
f) javac -jar program.jar:. b/A.java
g) javac -cp program.jar:b b/A.java
h) javac -cp program.jar:. b/A.java

3.4 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o Test. Arquivo no diretório atual:

import model.A;

class Test {
    public static void main(String[] args) {
        new A("guilherme").print();
    }
}

Arquivo no diretório model:

package model;

class A {
    private String name;
    
    A(String name) {
        this.name = name;
    }

    public void print() {
        System.out.println(name);
    }
}

a) Não compila: erro na classe Test.
b) Não compila: erro na classe A.
c) Erro de execução: método main.
d) Roda e imprime “Guilherme”.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

import model.basic.Client;
import model.advanced.Client;

class Test {
    public static void main(String[] args) {
        System.out.println("Welcome!");
    }
}

No arquivo model/basic/Client.java:

public class Client{}

No arquivo model/advanced/Client.java:

public class Client{}

a) O código do primeiro arquivo não compila, erro ao tentar importar
duas classes com o mesmo nome.
b) O código do terceiro arquivo não compila, erro ao tentar definir uma
classe com o nome de uma classe que já existe.
c) O código todo compila, mas ao rodar dá erro por ter importado duas
classes com o mesmo nome.
d) O código todo compila e roda imprimindo Welcome!, uma vez que
nenhuma das classes importadas é usada no código, não existe ambiguidade.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

import model.basic.Client;
import model.advanced.*;

class Test {
    public static void main(String[] args) {
        System.out.println("Welcome " + new Client().name);
    }
}

No arquivo model/basic/Client.java:

public class Client{
    public String name="guilherme";
}

No arquivo model/advanced/Client.java:

public class Client{
    public String name = "mario";
}

a) O código do primeiro arquivo não compila, erro ao tentar importar
duas classes com o mesmo nome.
b) O código compila mas ao rodar dá erro por ter importado duas classes
com o mesmo nome.
c) O código compila e roda imprimindo Welcome guilherme.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

import model.basic.Client;
import model.basic.Client;

class Test {
    public static void main(String[] args) {
        System.out.println("Welcome " + new Client().name);
    }
}

No arquivo model/basic/Client.java:

public class Client{
    public String name="guilherme";
}

a) O código do primeiro arquivo não compila, erro ao tentar importar
duas classes com o mesmo nome.
b) O código compila, mas ao rodar dá erro por ter importado duas classes
com o mesmo nome.
c) O código compila e roda imprimindo Bem vindo!, uma vez que não
há ambiguidade.

5 - Escolha a opção adequada ao tentar compilar os arquivos a seguir:
a/A.java:

package a;

class A {
    b.B variable;
}

a/C.java:

package a;

class C {
    b.B variable;
}

a/b/B.java:

package a.b;

class B {
}

a) Erro de compilação somente no arquivo A.
b) Erro de compilação somente no arquivo B.
c) Erro de compilação somente no arquivo C.
d) Erro de compilação nos arquivos A e B.
e) Erro de compilação nos arquivos A e C.
f) Erro de compilação nos arquivos B e C.
g) Compila com sucesso.

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

package A;

class B{
    public static void main(String[] a) {
        System.out.println("running");
    }
}

a) Não compila: a variável do método main deve se chamar args.
b) Não compila: pacote com letra maiúscula.
c) Compila mas não roda: a classe B não é pública.
d) Compila e roda.

7 - Escolha a opção adequada ao tentar compilar os arquivos a seguir:
a/A.java:

package a;

public class A {
    public static final int VALUE = 15;

    public void run(int x) {
        System.out.println(x);
    }
}

b/B.java:

package b;

import static a.A.*;

class B{
    void m() {
        A a = new A();
        a.run(VALUE);
    }
}

a) B não compila: erro na linha 2.
b) B não compila: erro na linha 5.
c) B não compila: erro na linha 6.
d) Tudo compila.

8 - Escolha a opção adequada ao tentar compilar os arquivos a seguir:
a/A.java:

package a;

public class A {
    public static final int VALUE = 15;

    public void run(int x) {
        System.out.println(x);
    }
}

b/B.java:

package b;

import a.A;
import static a.A.*;

class B{
    void m() {
        A a = new A();
        a.run(VALUE);
    }
}

a) B não compila: erro na linha 3.
b) B não compila: erro na linha 5.
c) B não compila: erro na linha 6.
d) Tudo compila.


9 - Escolha a opção adequada ao tentar compilar os arquivos a seguir:
A.java:

public class A {
    public static final int VALUE = 15;

    public void run(int x) {
        System.out.println(x);
    }
}

b/B.java:

package b;

import static A.*;

class B{
    void m() {
        A a = new A();
        a.run(VALUE);
    }
}

a) Não compila
b) Tudo compila.

4.1 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int age = 100;
        System.out.println(age);
    }
}

a) O código não compila: erros a partir da linha que define uma variável do tipo int.
b) O código não compila: a variável age não foi inicializada, mas foi usada em System.out.println.
c) O código compila e imprime 0.
d) O código compila e imprime 100.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int age;
        if(args.length > 0) {
            age = Integer.parseInt(args[0]);
        } else {
            System.err.println("???");
        }
        System.out.println(age);
    }
}

a) Não compila: erro na linha que tenta acessar a variável age.
b) Compila e imprime 0 ou a idade que for passada na linha de comando.
c) Compila e imprime a idade que for passada na linha de comando.
d) Compila e imprime a mensagem de erro ou imprime a idade.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int age;
        if(args.length > 0) {
            age = Integer.parseInt(args[0]);
        } else {
            System.err.println("???");
            return;
        }
        System.out.println(age);
    }
}

a) Não compila: erro na linha que tenta acessar a variável age.
b) Compila e imprime 0 ou a idade que for passada na linha de comando.
c) Compila e imprime a idade que for passada na linha de comando.
d) Compila e imprime a mensagem de erro ou imprime a idade.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        boolean array = new boolean[300];
        System.out.println(array[3]);
    }
}

a) Imprime true.
b) Imprime false.
c) Imprime 0.
d) Imprime -1.
e) Imprime null.
f) Não compila.

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        boolean[] array = new boolean[300];
        System.out.println(array[3]);
    }
}

a) Imprime true.
b) Imprime false.
c) Imprime 0.
d) Imprime -1.
e) Imprime null.
f) Não compila.

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        boolean argis;
        if(args.length > 0)
            argis = true;
        else
            argis = false;
        System.out.println(argis);
    }
}

a) Não compila: o método de impressão não recebe boolean.
b) Não compila: atribuição inválida.
c) Não compila: o método length de array não é uma propriedade.
d) Não compila: o método length de String[] não é uma propriedade.
e) Compila e imprime 0 ou 1.
f) Compila e imprime false ou true.

7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:


class A {
    public static void main(String[] args) {
        int n = 09;
        int m = 03;
        int x = 1_000;
        System.out.println(x - n + m);
    }
}

a) Não compila: erro na linha que declara n.
b) Não compila: erro na linha que declara x.
c) Não compila: erro na linha que declara m.
d) Compila e imprime um número menor que 1000.

8 -  Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        for(char c='a'; c <= 'z'; c++) {
            System.out.println(c);
        }
    }
}

a) Não compila: não podemos somar um em um caractere.
b) Não compila: não podemos comparar caracteres com <.
c) Compila e imprime o alfabeto entre a e z, inclusive.

9 - Qual das palavras a seguir não é reservada em Java?

a) strictfp
b) native
c) volatile
d) transient
e) instanceOf

10 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:
class A {
    public static void main(String[] args) {
        boolean BOOLEAN = false;
        if(BOOLEAN) {
            System.out.println("Yes");
        }
    }
}

a) Não compila: não podemos declarar uma variável com o nome de uma palavra reservada.
b) Não compila: não podemos declarar uma variável iniciando com letras maiúsculas.
c) Compila e roda, imprimindo Yes.
d) Compila e roda, não imprimindo nada.

4.2 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int x = 15;
        int y = x;
        y++;
        x++;
        int z = y;
        z--;
        System.out.println(x + y + z);
    }
}

a) Imprime 43.
b) Imprime 44.
c) Imprime 45.
d) Imprime 46.
e) Imprime 47.
f) Imprime 48.
g) Imprime 49.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    int v = 15;
}

class A {
    public static void main(String[] args) {
        B x = new B();
        B y = x;
        y.v++;
        x.v++;
        B z = y;
        z.v--;
        System.out.println(x.v + y.v + z.v);
    }
}

a) Imprime 43.
b) Imprime 44.
c) Imprime 45.
d) Imprime 46.
e) Imprime 47.
f) Imprime 48.
g) Imprime 49.

4.3 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B{
    int c;
    void c(int c) {
        c = c;
    }
}

class A {
    public static void main(String[] args) {
        B b = new B();
        b.c = 10;
        System.out.println(b.c);
        b.c(30);
        System.out.println(b.c);
    }
}

a) Não compila: conflito de nome de variável membro e método em B.
b) Não compila: conflito de nome de variável membro e variável local em B.
c) Compila e roda, imprimindo 10 e 30.
d) Compila e roda, imprimindo outro resultado.

4.4 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
}

class A {
    public static void main(String[] args) {
        B b;
        for(int i = 0; i < 10; i++)
            b = new B();
        System.out.println("end!");
    }
}

a) Não compila.
b) Compila e garbage coleta 10 objetos do tipo B na linha do System.out.
c) Compila e não podemos falar quantos objetos do tipo B foram garbage coletados na linha do System.out.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
}

class A {
    public static void main(String[] args) {
        B b = new B();
        for(int i = 0; i < 10; i++)
            b = new B();
        System.out.println("end!");
    }
}

a) Não compila.
b) Compila e 10 objetos do tipo B podem ser garbage coletados ao chegar na linha do System.out.
c) Compila e 11 objetos do tipo B podem ser garbage coletados ao chegar na linha do System.out.
d) Compila e garbage coleta 11 objetos do tipo B na linha do System.out.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
}

class A {
    public static void main(String[] args) {
        B[] bs = new B[100];
        System.out.println("end!");
    }
}

a) Compila e 100 objetos do tipo B são criados, mas não podemos falar nada sobre o garbage collector ter jogado os objetos fora na linha do System.out.
b) Compila e nenhum objeto do tipo B é criado.
c) Compila, cria 100 e joga fora todos os objetos do tipo B ao chegar no System.out.

4.5 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    void x() {
        System.out.println("empty");
    }
    
    void x(String... args) {
        System.out.println(args.length);
    }
}

class C {
    void x(String... args) {
        System.out.println(args.length);
    }
    
    void x() {
        System.out.println("empty");
    }
}

class A {
    public static void main(String[] args) {
        new B().x();
        new C().x();
    }
}

a) Não compila: conflito entre método com varargs e sem argumentos.
b) Compila e imprime empty/empty.
c) Compila e imprime empty/0.
d) Compila e imprime 0/empty.
e) Compila e imprime 0/0.

2  - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    void x(int... x) {
        System.out.println(x.length);
    }
}

class A {
    public static void main(String[] args) {
        new B().x(23789, 673482);
    }
}

a) Não compila: varargs tem método e não atributo length.
b) Compila e ao rodar imprime os dois números.
c) Compila e ao rodar imprime 2.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    void x(int... x) {
        System.out.println(x.length);
    }
}

class A {
    public static void main(String[] args) {
        new B().x(new int[]{23789, 673482});
    }
}

a) Não compila: varargs tem método e não atributo length.
b) Não compila: não podemos passar um array para um varargs.
c) Compila e ao rodar imprime os dois números.
d) Compila e ao rodar imprime 1.
e) Compila e ao rodar imprime 2.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    void x(Object... x) {
        System.out.println(x.length);
    }
}

class A {
    public static void main(String[] args) {
        new B().x(new Object[]{23789, 673482});
    }
}

a) Não compila: varargs tem método e não atributo length.
b) Não compila: não podemos passar um array para um varargs.
c) Compila e ao rodar imprime os dois números.
d) Compila e ao rodar imprime 1.
e) Compila e ao rodar imprime 2.


4.6 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("guilherme").delete(2, 3);
        System.out.println(sb);
    }
}

a) O código não compila: erro na linha que tenta imprimir o StringBuilder.
b) O código compila e imprime glherme.
c) O código compila e imprime guherme.
d) O código compila e imprime gilherme.
e) O código compila e imprime gulherme.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder("guilherme");
        System.out.println(sb.indexOf("e") + sb.lastIndexOf("e"));
        System.out.println(sb.indexOf("k") + sb.lastIndexOf("k"));
    }
}

a) O código imprime 13 e -2.
b) O código imprime 13 e 0.
c) O código imprime 13 e -1.
d) O código imprime 13 e 8.
e) O código imprime 13 e 10.
f) O código imprime 15 e -2.
g) O código imprime 15 e 0.
h) O código imprime 15 e -1.
i) O código imprime 15 e 8.
j) O código imprime 15 e 10.

4.7 Exercícios

1 - Considere o seguinte código dentro de um main:

class A {
    public static void main(String[] args) {
        String s = "aba";
        for (int i = 0; i < 9; i++) {
            s = s + "aba";
        }
        System.out.println(s.length());
    }
}

a) Não compila.
b) Compila e imprime 3.
c) Compila e imprime 30.
d) Compila e imprime 33.
e) Compila e imprime 36.

2 - Dada a seguinte classe:

class B {
    String msg;
    void imprime() {
        if (!msg.isEmpty())
            System.out.println(msg);
        else
            System.out.println("empty");
    }
}

O que acontece se chamarmos `new B().imprime()`?
a) Não compila.
b) Compila, mas dá exceção na hora de rodar.
c) Compila, roda e não imprime nada.
d) Compila, roda e imprime “empty”.

3 - Dada a seguinte classe:

class B {
    void imprime() {
        String msg;
        if (!msg.isEmpty())
            System.out.println(msg);
        else
            System.out.println("empty");
    }
}

O que acontece se chamarmos `new B().imprime()`?
a) Não compila.
b) Compila, mas dá exceção na hora de rodar.
c) Compila, roda e não imprime nada.
d) Compila, roda e imprime “empty”.

4 - Qual é a saída nos dois casos?

String s = "Caelum";
s.concat(" - Ensino e Inovação");
System.out.println(s);

StringBuffer sb = new StringBuffer("Caelum");
sb.append(" - Ensino e Inovação");
System.out.println(sb);

a) ‘Caelum‘ e ‘Caelum - Ensino e Inovação‘.
b) ‘Caelum - Ensino e Inovação‘ e ‘Caelum - Ensino e Inovação‘.

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String empty = null;
        String full = "Welcome " + empty;
        System.out.println(full);
    }
}

a) Não compila pois `empty` é nulo.
b) Não compila por outro motivo.
c) Compila e imprime “Welcome “.
d) Compila e imprime “Welcome empty”.
e) Compila e imprime outro resultado que não foi mencionado nessas alternativas.

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String empty;
        String full = "Welcome " + empty;
        System.out.println(full);
    }
}

a) Não compila pois `empty` é nulo.
b) Não compila por outro motivo.
c) Compila e imprime “Welcome “.
d) Compila e imprime “Welcome vazio”.
e) Compila e imprime outro resultado que não foi mencionado nessas alternativas.

7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    String empty;
    public static void main(String[] args) {
        String full = "Welcome " + empty;
        System.out.println(full);
    }
}

a) Não compila pois `empty` é nulo.
b) Não compila por outro motivo.
c) Compila e imprime “Welcome “.
d) Compila e imprime “Welcome empty”.
e) Compila e imprime outro resultado que não foi mencionado nessas alternativas.

8 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    static String empty;
    public static void main(String[] args) {
        String full = "Welcome " + empty;
        System.out.println(full);
    }
}

a) Não compila pois `empty` é nulo.
b) Não compila por outro motivo.
c) Compila e imprime “Welcome “.
d) Compila e imprime “Welcome empty”.
e) Compila e imprime outro resultado que não foi mencionado nessas alternativas.

9 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String s = null;
        String s2 = new String(s);
        System.out.println(s2);
    }
}

a) Não compila ao tentar invocar o construtor.
b) Compila e não imprime nada.
c) Compila e imprime null.
d) Compila e dá erro de execução ao tentar criar a segunda String.

10 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String s = "estudando para a certificação";
        System.out.println(s.substring(3, 6));
    }
}

a) Não compila: caractere com acento e cedilha dentro de uma String.
b) Não compila: `substring` é `subString`.
c) Compila e imprime “uda”.
d) Compila e imprime “tuda”.
e) Compila e imprime “tud”.

11 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String s2 = new String(null);
        System.out.println(s2);
    }
}

a) Não compila ao tentar invocar o construtor.
b) Compila e não imprime nada.
c) Compila e imprime null.
d) Compila e dá erro de execução ao tentar criar a String.

12 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int val = 10;
        int div = 4;
        double res = val / div;
        System.out.println(val + div + "...");
        System.out.println(res + " = result");
    }
}

a) Imprime os números 10, 4 e 2.5.
b) Imprime os números 14 e 2.5.
c) Nenhuma das outras alternativas.

13 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String s = "estudando para a cert

ificação";
        s.replace("e", 'a');
        System.out.println(s);
    }
}

a) Não compila.
b) Compila e imprime “estudando para a certificação”.
c) Compila e imprime “astudando para a cartificação”.
d) Compila e imprime “studando para a crtificação”.

14 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String s = "guilherme";
        s.substring(0, 2) = "gua";
        System.out.println(s);
    }
}

a) Erro de compilação.
b) Compila e imprime “guilherme”.
c) Compila e imprime “gualherme”.

5.1 Exercícios

1 - Qual código a seguir compila?
a) short s = 10; char c = s;
b) char c = 10; long l = c;
c) char c = 10; short s = c;

2 - Faça contas com diferentes operandos:

int i1 = 3/2;
double i2 = 3/2;
double i3 = 3/2.0;
long x = 0; double d = 0;
double zero = x + d;
System.out.println(i1 + i2 + i3 + x + d + zero);

Qual o resultado?
a) 3
b) 3.5
c) 4
d) 4.5

3 - O código a seguir pode lançar um NullPointerException. Como evitar isso mantendo a mesma lógica?

void method(Car c) {
    if(c != null & c.getPreco() > 100000) {
        System.out.println("expensive");
    }
}

a) Trocando != por ==
b) Trocando > por <
c) Trocando & por |
d) Trocando & por &&

4 - Alguns testes interessantes com tipos primitivos:

int i = (byte) 5;
long l = 3.0;
float f = 0.0;
char c = 3;
char c2 = -2;

Quais compilam?
a) i, f e c
b) i, f, c e c2
c) i, f e c2
d) i e c
e) f e c
f) f e c2
g) i e l
h) l, f e c
i) i, c e c2

5 - A expressão a seguir pode ser reduzida, como podemos fazer?

if ((train && !car) || (!train && car)) {
    // ....
}

- Trocando para usar um operador & e um |
- Trocando para usar dois operadores & e um |
- Trocando para usar um operador ! e um ^
- Trocando para usar um operador ^
- Removendo os parênteses
- Removendo o || do meio
- Removendo os !

6 - Imprima a divisão por 0 de números inteiros e de números com ponto flutuante:

System.out.println(3 / 0);
System.out.println(3 / 0.0);
System.out.println(3.0 / 0);
System.out.println(-3.0 / 0);

Quais os resultados?

7 - Leia o código abaixo:
class Xyz {
    public static void main(String[] args) {
        int y;
        for(int x = 0; x<10; ++x) {
            y = x % 5 + 2;
        }
        System.out.println(y);
    }
}

Qual o resultado desse código?
a) Erro de compilação na linha 3
b) Erro de compilação na linha 7
c) 1
d) 2
e) 3
f) 4
g) 5
h) 6

8 - Leia o código abaixo:

class Test {
    public static void main(String[] args){
        byte b = 1;
        int i = 1;
        long l = 1;
        float f = 1.0;
    }
}

O código:
a) Não compila a linha 3 pois “1” é int e não pode ser colocado em um byte
b) Não compila a linha 4 pois “1” é long e não pode ser colocado em um int
c) Não compila a linha 5 pois “1” é int e não pode ser colocado em um long
d) Não compila a linha 6 pois “1.0” é double e não pode ser colocado em um float
e) Todas as linhas compilam

9 - Leia o código abaixo: 

class $_o0o_$ {
    public static void main(String[] args) {
        int $$ = 5;
        int __ = $$++;
        if (__ < ++$$ || __-- > $$)
            System.out.print("A");
        System.out.print($$);
        System.out.print(__);
    }
}

O estranho código:
a) Não compila por causa do nome da classe
b) Não compila por causa dos nomes das variáveis
c) Compila mas dá erro na execução
d) Compila, roda e imprime A76
e) Compila, roda e imprime A75
f) Compila, roda e imprime A74
g) Compila, roda e imprime 76

**Exercícios**

1 - O que acontece com o seguinte código? Compila? Roda?

public class Test{
    public static void main(String[] args) {
        byte b1 = 5;
        byte b2 = 3;
        byte b3 = b1 + b2;
    }
}


2 - O que acontece com seguinte código?

public class Test{
    public static void main(String[] args) {
        byte b1 = 127;
        byte b2 = -128;
        byte b3 = b1 + b2;
        System.out.println(b3);
    }
}

a) Não compila por um erro na linha 3
b) Não compila por um erro na linha 4
c) Não compila por um erro na linha 5
d) Compila e imprime -1

3 - Leia o código abaixo:

public class Test {
    public static void main(String[] args) {
        int i;
        for (i = 0; i < 5; i++) {
            if (++i % 3 == 0) {
                break;
            }
        }
        System.out.println(i);
    }
}

Qual é o resultado do código:
a) imprime 1
b) imprime 2
c) imprime 3
d) imprime 4

4 - Considerando o mesmo código da questão anterior, e se trocarmos para pós-incremento dentro do if?

public class Test {
    public static void main(String[] args) {
        int i;
        for (i = 0; i < 5; i++) {
            if (i++ % 3 == 0) {
                break;
            }
        }
        System.out.println(i);
    }
}

Qual é o resultado?:
a) imprime 1
b) imprime 2
c) imprime 3
d) imprime 4

5 - Qual é o resultado do seguinte código:

public class Test {
    public static void main(String[] args) {
        int i;
        for (

i = 0; i < 5; i++) {
            if (++i % 3 == 0) {
                break;
            }
        }
        System.out.println(i);
    }
}


6 - E se trocarmos o pré-incremento para pós-incremento ( i++)?

7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        byte b1 = 100;
        byte b2 = 131;
        System.out.println(b1);
    }
}

a) Compila e imprime um número positivo.
b) Compila e imprime um número negativo.
c) Compila e dá uma exception de estouro de número.
d) Compila e imprime um número que não sabemos dizer ao certo.
e) Compila e imprime “Not A Number”.
f) Não compila.

8 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        char c = 65;
        char c2 = -3;
        System.out.println(c + c2);
    }
}

a) Não compila nas duas declarações de char.
b) Não compila nas três linhas dentro do método main.
c) Não compila somente na declaração de c2.
d) Não compila somente na soma de caracteres.
e) Compila e roda, imprimindo 62.
f) Compila e roda, imprimindo um outro valor.

9 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        char c = 65;
        char c2 = 68 - 65;
        System.out.println(c + c2);
    }
}

a) Não compila nas duas declarações de char.
b) Não compila nas três linhas dentro do método main.
c) Não compila somente na declaração de c2.
d) Não compila somente na soma de caracteres.
e) Compila e roda, imprimindo 62.
f) Compila e roda, imprimindo um outro valor.

10 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        double result = 15 / 0;
        System.out.println(result);
    }
}

a) Não compila.
b) Compila e dá exception.
c) Compila e imprime positivo infinito.
d) Compila e imprime 0.

11 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String result = "results: " + 15 / 0.0;
        System.out.println(result);
    }
}

a) Não compila.
b) Compila e dá exception.
c) Compila e imprime positivo infinito.
d) Compila e imprime 0.

12 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        System.out.println(1==true);
    }
}

a) Não compila.
b) Compila e imprime verdadeiro.
c) Compila e imprime falso.

5.2 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
   public static void main(String[] args) {
      String result = ("division: " + 15) / 0.0;
      System.out.println(result);
   }
}

a) Não compila.
b) Compila e dá exception.
c) Compila e imprime positivo infinito.
d) Compila e imprime 0.

2) Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
   public static void main(String[] args) {
      System.out.println(((!(true == false)) == true ? 1 : 0) == 0);
   }
}

a) Imprime true.
b) Imprime false.
c) Não compila.
d) Imprime 1.
e) Imprime 0.

5.3 Exercícios

1 - class A {

public static void main(String[] args) {
   String s1 = "s1";
   String s2 = "s" + "1";
   System.out.println(s1 == s2);
   System.out.println(s1 == ("" + s2));
}

a) Não compila.
b) Compila e imprime true, false.
c) Compila e imprime true, true.
d) Compila e imprime false, false.
e) Compila e imprime false, true.

2 - class A {

public static void main(String[] args) {
   String s1 = "s1";
   String s2 = s1.substring(0, 1) + s1.substring(1, 1);
   System.out.println(s1 == s2);
   System.out.println(s1.equals(s2));
}

a) Não compila.
b) Compila e imprime true, false.
c) Compila e imprime true, true.
d) Compila e imprime false, false.
e) Compila e imprime false, true.

3 - class A {

public static void main(String[] args) {
   String s1 = "s1";
   String s2 = s1.substring(0, 2);
   System.out.println(s1 == s2);
   System.out.println(s1.equals(s2));
}

a) Não compila.
b) Compila e imprime true, false.
c) Compila e imprime true, true.
d) Compila e imprime false, false.
e) Compila e imprime false, true.

4 - class B extends C {}

class C {
   int x;

   public boolean equals(C c) {
      return c.x == x;
   }
}
class A {
   public static void main(String[] args) {
      C a = new C();
      C b = new B();
      a.x = 1;
      b.x = 1;
      System.out.println(a == b);
      System.out.println(a.equals(b));
   }
}

a) Não compila.
b) Compila e imprime true, false.
c) Compila e imprime true, true.
d) Compila e imprime false, false.
e) Compila e imprime false, true.

5 - class B extends C {}

class D {
   int x;
}
class C {
   int x;

   public boolean equals(Object c) {
      return ((C) c).x == x;
   }
}
class A {
   public static void main(String[] args) {
      C a = new C();
      C b = new D();
      a.x = 1;
      b.x = 1;
      System.out.println(a == b);
      System.out.println(a.equals(b));
   }
}

a) Não compila.
b) Compila e imprime true, false.
c) Compila e imprime true, true.
d) Compila e imprime false, false.
e) Compila e imprime false, true.

5.4 Exercícios

1 - class A {

public static void main(String[] args) {
   if (args.length > 0)
      System.out.println("1 or more");
   else
      System.out.println("0");
}

a) Não compila: length é método.
b) Não compila: faltou chaves no if e else.
c) Se invocarmos sem argumentos, imprime 0.
d) Nunca imprimirá 0.

2 - class B {

final boolean valor = false;
}
class A {
   public static void main(String[] args) {
      B b = new B();
      if (b.valor = true) {
         System.out.println("uhu true");
      }
   }
}

a) Não compila.
b) Compila e imprime uhu true.
c) Compila e não imprime nada.

3 - class A {

public static void main(String[] args) {
   int qt = 15;
   if (qt = 15) {
      System.out.println("yes");
   } else {
      System.out.println("no");
   }
}

a) Não compila.
b) Imprime sim.
c) Imprime não.

4 - class A {

public static void main(String[] args) {
   if (args.length == 1)
      System.out.println("one");
   elseif (args.length == 2)
      System.out.println("two");
   elseif (args.length == 3)
      System.out.println("three");
   else
      System.out.println("four");
}

a) Não compila.
b) Roda e imprime “one” quando passamos um argumento.
c) Roda e imprime “three” quando passamos 4 argumentos.
d) Roda e não imprime nada quando passamos nenhum argumento.

5 - class A {

public static void main(String[] args) {
   String name = args[0];
   if (name.equals("guilherme"))
      System.out.println(name);
   System.out.println("good");
   else
      System.out.println("better");
   System.out.println(name);
}

a) Erro de compilação no if.
b) Erro de compilação no else.
c) Compila e imprime o nome e “good” caso o primeiro argumento seja guilherme.
d) Compila e dá erro de execução caso não passe nenhum argumento na linha de comando.

5.5 Exercícios

1 - class A {

public static void main(String[] args) {
   int t = args.length;
   switch(t) {
      case 1:
         System.out.println("1");
      case 2:
         System.out.println("2");
      default:
         System.out.println("+++");
   }
}

a) Não compila.
b) Ao rodar sem argumentos, joga uma exception.
c) Ao rodar com dois argumentos, imprime somente “2”.
d) Ao rodar com 5 argumentos, imprime “+++”.

2 - class A {

public static void main(String[] args) {
   int t2 = 1;
   int t = args.length;
   switch(t) {
      case t2:
         System.out.println("1");
         break;
      default:
         System.out.println("arg???");
   }
}

a) Não compila.
b) Ao rodar sem argumentos, joga uma exception.
c) Ao rodar com um argumento, imprime somente “1”.
d) Ao rodar com 5 argumentos, imprime “arg???”.

3 - class A {

public static void main(String[] args) {
   switch("Guilherme") {
      case "Guilherme":
         System.out.println("Guilherme");
         break;
      case "42":
         System.out.println("42");
      default:
         System.out.println("Mario");
   }
}

a) Não compila, pois um número não pode ser comparado com String.
b) Compila e imprime Guilherme.
c) Não compila, pois o código do case 42 e default nunca serão executados.

4 - class A {

public static void main(String[] args) {
   int count = args.length;
   switch(count) {
      case 0: {
         System.out.println("---");
         break;
      }
      case 1:
      case 2: {
         System.out.println("ok");
         break;
      }
      default: {
         System.out.println("default");
      }
   }
}

a) Erro de compilação.
b) Se rodar com 1 argumento, imprime ok e mais uma mensagem.
c) Se rodar com 1 argumento, não imprime nada.
d) Se rodar com 5 argumentos, imprime default.

5 - class A {

public static void main(String[] args) {
   switch(10) {
      case < 10:
         System.out.println("<");
      default:
         System.out.println("=");
      case > 10:
         System.out.println(">");
   }
}

a) Erro de compilação.
b) Compila e imprime “=”.
c) Compila e imprime “=” e “>”.

6 - class A {

public static void main(String[] args) {
   switch(10) {
      case 10:
         System.out.println("a");
         break;
      case 11:
         System.out.println("d");
      default:
         System.out.println("c");
   }
}

a) Não compila.
b) Imprime a e b e c e d.
c) Imprime a.

5.4 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        if(args.length > 0)
            System.out.println("1 or more");
        else
            System.out.println("0");
    }
}

a) Não compila: `length` é método.

b) Não compila: faltou chaves no `if` e `else`.

c) Se invocarmos sem argumentos, imprime 0.

d) Nunca imprimirá 0.


2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    final boolean valor = false;
}

class A {
    public static void main(String[] args) {
        B b = new B();
        if(b.valor = true) {
            System.out.println("uhu true");
        }
    }
}

a) Não compila.

b) Compila e imprime "uhu true".

c) Compila e não imprime nada.



3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int qt = 15;
        if(qt=15) {
            System.out.println("yes");
        } else {
            System.out.println("no");
        }
    }
}

a) Não compila.

b) Imprime "yes".

c) Imprime "no".


4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        if(args.length==1)
            System.out.println("one");
        elseif(args.length==2)
            System.out.println("two");
        elseif(args.length==3)
            System.out.println("three");
        else
            System.out.println("four");
    }
}

a) Não compila.

b) Roda e imprime "one" quando passamos um argumento.

c) Roda e imprime "three" quando passamos 4 argumentos.

d) Roda e não imprime nada quando passamos nenhum argumento.


5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String name = args[0];
        if(name.equals("guilherme"))
            System.out.println(name);
        System.out.println("good");
        else
            System.out.println("better");
        System.out.println(name);
    }
}

a) Erro de compilação no `if`.

b) Erro de compilação no `else`.

c) Compila e imprime o nome e "good" caso o primeiro argumento seja guilherme.

d) Compila e dá erro de execução caso não passe nenhum argumento na linha de comando.


5.5 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int t = args.length;
        switch(t) {
            case 1:
                System.out.println("1");
            case 2:
                System.out.println("2");
            default:
                System.out.println("+++");
        }
    }
}

a) Não compila.

b) Ao rodar sem argumentos joga uma exception.

c) Ao rodar com dois argumentos, imprime somente “2”.

d) Ao rodar com 5 argumentos, imprime “+++”.


2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int t2 = 1;
        int t = args.length;
        switch(t) {
            case t2:
                System.out.println("1");
                break;
            default:
                System.out.println("arg???");
        }
    }
}

a) Não compila.

b) Ao rodar sem argumentos joga uma exception.

c) Ao rodar com um argumento, imprime somente “1”.

d) Ao rodar com 5 argumentos, imprime “arg???”


3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        switch("Guilherme") {
            case "Guilherme":
                System.out.println("Guilherme");
                break;
            case "42":
                System.out.println("42");
            default:
                System.out.println("Mario");
        }
    }
}

a) Não compila, pois um número não pode ser comparado com String.

b) Compila e imprime Guilherme.

c) Não compila, pois o código do case 42 e default nunca serão executados.


4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int count = args.length;
        switch(count) {
            case 0:
                System.out.println("---");
                break;
            case 1:
            case 2:
                System.out.println("ok");
                break;
            default:
                System.out.println("default");
        }
    }
}

a) Erro de compilação.

b) Se rodar com 1 argumento, imprime ok e mais uma mensagem.

c) Se rodar com 1 argumento, não imprime nada.

d) Se rodar com 5 argumentos, imprime default.


5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        switch(10) {
            case < 10:
                System.out.println("<");
            default:
                System.out.println("=");
            case > 10:
                System.out.println(">");
        }
    }
}

a) Erro de compilação.

b) Compila e imprime “=” e “>”.

c) Compila e imprime “=”.


6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        switch(10) {
            case 10:
                System.out.println("a");
                break;
            case 11:
                System.out.println("d");
            default:
                System.out.println("c");
        }
    }
}

a) Não compila.

b) Imprime a e b e c e d.

c) Imprime a.

6.1 Exercícios

1 - Escolha a opção que não compila:
a) int[] x;
b) int x[];
c) int[]x;
d) int [] x;
e) []int x;

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int x[] = new int[30]; // A
        int y[] = new int[3] {0,3,5}; // B
    }
}

a) A linha A não compila.

b) A linha B não compila.

c) O código compila e roda.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir, em relação às linhas dentro do método main:

class A {
    public static void main(String[] args) {
        int x[] = new int[0];
        int x[] = new int[] {0,3,5};
        int x[] = {0,3,5};
    }
}

a) A primeira e segunda linhas não compilam.

b) A segunda e terceira linhas não compilam.

c) Somente a terceira linha não compila.

d) O programa compila e roda, dando uma exception.

e) O programa compila e roda, imprimindo nada.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int x[] = new int[3];
        for(int i=x.length;i>=0;i--) x[i]=i*2;
        System.out.println("end!");
    }
}

a) O programa não compila.

b) O programa imprime end!.

c) O programa compila e dá erro em execução.

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int x[] = new int[3];
        for(x[1]=x.length-1;x[0]==0;x[1]--) {
            x[x[1]]=-5;
            System.out.println(x[1]);
        }
    }
}

a) Não compila.

b) Compila, imprime alguns números e dá uma Exception.

c) Compila e não imprime nada.

d) Compila e imprime 2.

e) Compila e imprime -5.

f) Compila e imprime 2, -5.

g) Compila e imprime 2, -5, -5.

h) Compila e imprime 2, 1, -5.

i) Compila e imprime -5, -5.

j) Dá exception.

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int x[] = new int[3];
        for(x[1]=x.length-1;x[1]>=0;x[1]--) {
            x[x[1]]=-5;
            System.out.println(x[1]);
        }
    }
}

a) Não compila.

b) Compila, imprime alguns números e dá uma Exception.

c) Compila e não imprime nada.

d) Compila e imprime 2.

e) Compila e imprime -5.

f) Compila e imprime 2, -5.

g) Compila e imprime 2, -5, -5.

h) Compila e imprime 2, 1, -5.

i) Compila e imprime -5, -5.

j) Dá exception.

7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String[] valores = new String[2];
        valores[0] = "Certification";
        valores[1] = "Java";
        Object[] vals = (Object[]) valores;
        vals[1] = "Daniela";
        System.out.println(vals[1].equals(valores[1]));
    }
}

a) O código não compila.

b) O código compila e dá erro em execução.

c) O código compila e imprime false.

d) O código compila e imprime true.

8 - Quais das maneiras adiante são declarações e inicializações válidas para um array?

a) int[] array = new int[10];

b) int array[] = new int[10];

c) int[] array = new int[];

d) int array[] = new int[];

e) int[] array = new int[2]{1, 2};

f) int[] array = new int[]{1, 2};

g) int[] array = int[10];

h) int[] array = new int[1, 2, 3];

i) int array[] = new int[1, 2, 3];

j) int array[] = {1, 2, 3};


6.2 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int zyx[][] = new int[3];
        int[] x = new int[20];
        int[] y = new int[10];
        int[] z = new int[30];
        zyx[0] = x;
        zyx[1] = y;
        zyx[2] = z;
        System.out.println(zyx[2].length);
    }
}

a) Não compila, erro ao declarar zyx.

b) Compila e dá erro ao tentar atribuir o segundo array a zyx.

c) Compila e dá erro ao tentar imprimir o tamanho do array.

d) Compila e imprime 10.

e) Compila e imprime 20.

f) Compila e imprime 30.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int zyx[][] = new int[3][];
        int[] x = new int[20];
        int[] y = new int[10];
        int[] z = new int[30];
        zyx[0] = x;
        zyx[1] = y;
        zyx[2] = z;
        System.out.println(zyx[2].length);
    }
}

a) Não compila, erro ao declarar zyx.

b) Compila e dá erro ao tentar atribuir o segundo array a zyx.

c) Compila e dá erro ao tentar imprimir o tamanho do array.

d) Compila e imprime 10.

e) Compila e imprime 20.

f) Compila e imprime 30.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int zyx[][] = new int[3][10];
        int[] x = new int[20];
        int[] y = new int[10];
        int[] z = new int[30];
        zyx[0] = x;
        zyx[1] = y;
        zyx[2] = z;
        System.out.println(zyx[2].length);
    }
}

a) Não compila, erro ao declarar zyx.

b) Não compila, erro ao atribuir arrays de tamanho diferente de 10 em zyx.

c) Compila e dá erro ao tentar atribuir o segundo array a zyx.

d) Compila e dá erro ao tentar imprimir o tamanho do array.

e) Compila e imprime 10.

f) Compila e imprime 20.

g) Compila e imprime 30.

4 - 

class Test {
    public static void main(String[] args) {
        int[] id = new int[10];
        id[0] = 1.0;
        int[10][10] tb = new int[10][10];
        int[][][] cb = new int[][][];
    }
}


a) O código não compila.

b) O código compila e dá erro em execução.

c) O código compila e roda.

Compila? Roda?

6.3 Exercícios

1 - 

class A {
    public static void main(String[] args) {
        ArrayList<String> c = new ArrayList<String>();
        c.add("a");
        c.add("c");
        System.out.println(c.remove("a"));
    }
}

a) Não compila: erro ao declarar a ArrayList.
b) Não compila: erro ao invocar remove.
c) Compila e ao rodar imprime "a".
d) Compila e ao rodar imprime true.
e) Compila e ao rodar imprime false.

2 -

import java.util.ArrayList;

class A {
    public static void main(String[] args) {
        ArrayList<String> c = new ArrayList<String>();
        c.add("a");
        c.add("c");
        System.out.println(c.remove("a"));
    }
}

a) Não compila: erro ao declarar a ArrayList.
b) Não compila: erro ao invocar remove.
c) Compila e ao rodar imprime "a".
d) Compila e ao rodar imprime true.
e) Compila e ao rodar imprime false.

3 -

import java.util.ArrayList;

class A {
    public static void main(String[] args) {
        ArrayList<String> c = new ArrayList<String>();
        c.add("a");
        c.add("a");
        System.out.println(c.remove("a"));
        System.out.println(c.size());
    }
}

a) Não compila: erro ao declarar a ArrayList.
b) Não compila: erro ao invocar remove.
c) Compila e ao rodar imprime "a" e 0.
d) Compila e ao rodar imprime true e 0.
e) Compila e ao rodar imprime "a" e 1.
f) Compila e ao rodar imprime true e 1.
g) Compila e ao rodar imprime "a" e 2.
h) Compila e ao rodar imprime true e 2.

4 - 

import java.util.ArrayList;

class A {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("a");list.add("b");
        list.add("a");list.add("c");
        list.add("a");list.add("b");
        list.add("a");
        System.out.println(list.lastIndexOf("b"));
    }
}

a) Não compila.
b) Compila e imprime -1.
c) Compila e imprime 0.
d) Compila e imprime 1.
e) Compila e imprime 2.
f) Compila e imprime 3.
g) Compila e imprime 4.
h) Compila e imprime 5.
i) Compila e imprime 6.
j) Compila e imprime 7.

5 - 

import java.util.ArrayList;

class A {
    public static void main(String[] args) {
        ArrayList<String> l = new ArrayList<String>();
        l.add("a");
        l.add("b");
        l.add(1, "amor");
        l.add(3, "love");
        System.out.println(l);
        String[] array = l.toArray();
        System.out.println(array[2]);
    }
}

a) Não compila.
b) Compila e imprime “amor”.
c) Compila e imprime “b”.

6 -

import java.util.ArrayList;

class A {
    public static void main(String[] args) {
        ArrayList<String> a = new ArrayList<String>();
        ArrayList<String> b = new ArrayList<String>();
        ArrayList<String> c = new ArrayList<String>();
        b.add("a");
        c.add("c");
        b.add("b");
        c.add("d");
        a.addAll(b);
        a.addAll(c);
        System.out.println(a.get(0));
        System.out.println(a.get(3));
    }
}

a) Não compila
b) Compila e imprime "a" e "d".
c) Compila e imprime "c" e "b".
d) Compila e não sabemos a ordem em que os elementos serão impressos.

7 -

import java.util.ArrayList;

class A {
    public static void main(String[] args) {
        ArrayList<String> a = new ArrayList<String>();
        a.add("a", 0);
        a.add("b", 0);
        a.add("c", 0);
        a.add("d", 0);
        System.out.println(a.get(0));
        System.out.println(a.get(1));
        System.out.println(a.get(2));
        System.out.println(a.get(3));
    }
}

a) Não compila.
b) Compila e imprime "abcd".
c) Compila e imprime "dcba".
d) Compila e imprime "adcb".
e) Compila e imprime "bcda".

8 -

import java.util.*;

class A {
    public static void main(String[] args) {
        ArrayList<String> a = new ArrayList<String>();
        a.add(0, "b");
        a.add(0, "a");
        for (Iterator<String> i = a.iterator(); i.hasNext(); i.next()) {
            String element = i.next();
            System.out.println(element);
        }
    }
}

a) Não compila.
b) Compila e imprime "a".
c) Compila e imprime "a" e "b".
d) Compila e imprime "b" e "a".
e) Compila e imprime "b".

9 - 

import java.util.ArrayList;

class A {
    public static void main(String[] args) {
        ArrayList<String> ss = new ArrayList<String>();
        ss.add("a");
        ss.add("b");
        ss.add("c");
        ss.add("d");
        for (String s : ss) {
            if (s.equals("c")) s = "b";
            else if (s.equals("b")) s = "c";
        }
        for (String s : ss) System.out.println(s);
    }
}

a) Não compila, s é final por padrão.
b) Compila e imprime "a, c, b, d".
c) Compila e imprime "a, b, c, d".
d) Compila e imprime "a, c, c, d".
e) Compila e imprime "a, c, d, b".

7.1 Exercícios

1 -

class A {
    public static void main(String[] args) {
        int a = 10;
        while(a > 100)
            a++;
        System.out.println(a);
    }
}


a) Não compila pois nunca entra no loop.
b) Compila e imprime 99.
c) Compila e imprime 100.
d) Compila e imprime 101.
e) Compila e imprime outro valor.

2 -

class A {
    public static void main(String[] args) {
        boolean run = true;
        while(run) {
            System.out.println(run);
        }
        System.out.println("finish");
    }
}

a) Transformar a variável em final faz o código compilar.
b) Colocar uma linha dentro do laço que faz run = false faz o código compilar.
c) O código compila e roda em loop infinito.
d) O código compila e roda, após algumas passagens pelo laço ele imprime uma exception e para.

7.2 Exercícios

1 - 

class A {
    public static void main(String[] args) {
        for(;;) {
            System.out.println("a");
        }
        System.out.println("b");
    }
}

a) Não compila.
b) Compila e imprime "a" infinitamente.
c) Compila e imprime "b".
d) Compila e imprime "a", depois "b", depois para.
e) Compila, imprime "a" diversas vezes e depois joga um StackOverflowError.

2 - 

class A {
    public static void main(String[] args) {
        for(; false;) {
            System.out.println("a");
            break;
        }
        System.out.println("b");
    }
}

a) Não compila.
b) Compila e imprime "b".

3 - 

class A {
    public static void main(String[] args) {
        for(int i=0, int j=1; i<10; i++, j++)
            System.out.println(i);
    }
}

a) Não compila.
b) Compila e imprime 0 até 9.
c) Compila e imprime 0 até 10.
d) Compila e imprime 1 até 10.
e) Compila e imprime 1 até 11.

4 - 

class A {
    public static void main(String[] args) {
        for(int i=0, j=1; i<10 ;i++, j++)
            System.out.println(i);
    }
}

a) Não compila.
b) Compila e imprime 0 até 9.
c) Compila e imprime 0 até 10.
d) Compila e imprime 1 até 10.
e) Compila e imprime 1 até 11.

5 - 

class A {
    public static void main(String[] args) {
        for(int i=0; i<10, false; i++) {
            System.out.println('a');
        }
        System.out.println('b');
    }
}

a) Não compila.
b) Compila e imprime 'a' e 'b'.

6 - 

class A {
    public static void main(String[] args) {
        for(int i=0; i<2; i++, System.out.println(i)) {
            System.out.println(i);
        }
    }
}

a) Não compila.
b) Compila e imprime 0 1 2.
c) Compila e imprime 0 0 1 1 2 2.
d) Compila e imprime 0 1 1 2 2.
e) Compila e imprime 0 1 1 2.


7.3 Exercícios


1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        boolean i = false;
        do {
            System.out.println(i);
        } while(i);
    }
}

a) Não compila.
b) Compila e imprime false.
c) Compila e não imprime nada.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        if(args.length < 10) {
            do {
                if(args.length > 2)
                    return;
            } while(true);
        }
        System.out.println("finished");
    }
}

a) Não compila.
b) Compila e entra em loop infinito caso seja passado zero, um ou dois argumentos. Não imprime nada caso 3 a 9 argumentos. Imprime ‘finished’ caso 10 ou mais argumentos.
c) Compila e entra em loop infinito caso seja passado zero, um ou dois argumentos. Imprime ‘finished’ caso contrário.
d) Compila e sempre entra em loop infinito.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int i = 0;
        do 
            System.out.println(i);
        while(i++ > 10);
    }
}

a) Não compila.
b) Compila e não imprime nada.
c) Compila e imprime 0.
d) Compila e imprime de 0 até 9.
e) Compila e imprime de 0 até 10.
f) Compila e não imprime nada.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int i = 0;
        do 
            System.out.println(i) 
        while(i++ < 10);
    }
}

a) Não compila.
b) Compila e imprime de 0 até 9.
c) Compila e imprime de 0 até 10.
d) Compila e não imprime nada.

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int i = 0;
        do; while(i++ < 10);
    }
}

a) Não compila.
b) Compila e entra em loop infinito.
c) Compila e sai.

7.4 Exercícios

1 - Qual o laço mais simples de ser usado quando desejamos iterar por duas coleções ao mesmo tempo?
a) for
b) while
c) enhanced for
d) do... while

2 - Qual o melhor laço a ser usado para, dependendo do valor de um elemento, removê-lo de nossa lista?
a) for
b) enhanced for

3 - Para todos os números entre i e 100 devo imprimir algo, sendo que, mesmo que i seja maior que 100, devo imprimir algo pelo menos uma vez. Qual laço devo usar?
a) enhanced for
b) do... while
c) while

4 - Qual o laço a ser usado caso queira executar um código eternamente?
a) enhanced for
b) for
c) for ou while
d) for ou while ou do...while
e) while ou do...while

5 - Qual laço deve ser usado para inicializar os valores de um array?
a) enhanced for
b) for

7.5 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        outside: for(int a=0;a<30;a++)
            for(int b=0;b<1;b++)
                if(a+b==25) continue outside;
                else if(a+b==20) break outside;
                else if(a==0) break outside;
                else System.out.println(a);
    }
}

a) Não compila.

b) Compila e imprime 1 até 29.

c) Compila e não imprime nada.

d) Compila e imprime 1 até 19, 21 até 24, 26 até 29.

e) Compila e imprime 1 até 24, 26 até 29.

f) Compila e imprime 1 até 19.


2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        outside: for(int a=0;a<30;a++)
            for(int b=0;b<1;b++)
                if(a+b==25) continue outside;
                else if(a+b==20) break;
                else System.out.println(a);
    }
}

a) Não compila.

b) Compila e imprime 0 até 29.

c) Compila e não imprime nada.

d) Compila e imprime 0 até 19, 21 até 24, 26 até 29.

e) Compila e imprime 0 até 24, 26 até 29.

f) Compila e imprime 0 até 19.


3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:


class A {
    public static void main(String[] args) {
        int a = args.length;
        int i = 0;
        switch(a) {
            case 0:
            case 1:
                for(i=0;i<15;i++, System.out.println(i))
                    if(i==5) continue;
                    if(i==15) break;
            case 2:
                System.out.println("2");
        }
        System.out.println("end");
    }
}

a) Não compila.

b) Compila e ao rodar com 0 argumentos imprime 0 até 14, 2, end.

c) Compila e ao rodar com 0 argumentos imprime 1 até 15, 2, end.

d) Compila e ao rodar com 0 argumentos imprime 0 até 4, 6 até 14, 2, end.

e) Compila e ao rodar com 0 argumentos imprime 1 até 4, 6 até 15, end.

f) Compila e ao rodar com 0 argumentos imprime 0 até 4, 6 até 9, 2, end.

g) Compila e ao rodar com 0 argumentos imprime 1 até 4, 6 até 9, end.

h) Compila e ao rodar com 0 argumentos imprime 1 até 4, 6 até 15, 2, end.

i) Compila e ao rodar com 0 argumentos imprime 1 até 15, 2, end.

j) Compila e ao rodar com 0 argumentos imprime 1 até 15, end.


8.1 Exercícios


1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        x(args.length);
    }

    static int x(final int l) {
        for(int i=0;i<100;i++) {
            switch(i) {
                case l:
                    System.out.println(l);
                    if(l==i) return;
                case 0:
                    System.out.println(0);
            }
        }
        System.out.println("end");
        return -1;
    }
}

a) Não compila.

b) Compila e ao rodar com cinco parâmetros, imprime 0, 5 e end.

c) Compila e ao rodar com cinco parâmetros, imprime 0, 5, -1 e end.

d) Compila e ao rodar com cinco parâmetros, imprime 0 e 5.

e) Compila e ao rodar com cinco parâmetros, imprime 0, 5 e -1.

f) Compila e ao rodar com cinco parâmetros, imprime 0, 5, 0 e end.

g) Compila e ao rodar com cinco parâmetros, imprime 0, 5, 0, -1 e end.

h) Compila e ao rodar com cinco parâmetros, imprime 0 e 5.

i) Compila e ao rodar com cinco parâmetros, imprime 0, 5, 0 e -1.


2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        x(args.length);
    }

    static int x(final int l) {
        for(int i=0;i<100;i++) {
            switch(i) {
                case l:
                    System.out.println(l);
                    if(l==i) return 3;
                case 0:
                    System.out.println(0);
            }
        }
        System.out.println("End");
        return -1;
    }
}

a) Não compila.

b) Compila e ao rodar com cinco parâmetros, imprime 0, 5 e End.

c) Compila e ao rodar com cinco parâmetros, imprime 0, 5, -1 e End.

d) Compila e ao rodar com cinco parâmetros, imprime 0 e 5.

e) Compila e ao rodar com cinco parâmetros, imprime 0, 5 e -1.

f) Compila e ao rodar com cinco parâmetros, imprime 0, 5, 0 e End.

g) Compila e ao rodar com cinco parâmetros, imprime 0, 5, 0, -1 e End.

h) Compila e ao rodar com cinco parâmetros, imprime 0 e 5.

i) Compila e ao rodar com cinco parâmetros, imprime 0, 5, 0 e -1.


3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        System.out.println(a(args.length));
    }

    static int a(int l) {
        if(l<10) return b(l);
        else return c();
    }

    static int b(int l) {
        if(l<10) return b(l);
        else return c();
    }

    static long c() {
        return 3;
    }
}

a) Não compila: erro ao invocar o método b.

b) Não compila: erro ao invocar o método c.

c) Não compila por um motivo não listado.

d) Compila e, ao chamar com 15 argumentos, imprime 3.

e) Compila e, ao chamar com 15 argumentos, entra em loop infinito.


4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        System.out.println(a(args.length)[0]);
    }

    static int[] a(int l) {
        if(l==0) return new int[]{0, l};
        else return new int[]{l, 0};
    }
}

a) Não compila.

b) Ao invocar com nenhum parâmetro, imprime 0.

c) Ao invocar com 5 parâmetros, imprime 0.


8.2 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        x();
    }

    static x() {
        System.out.println("x");
        y();
    }

    static y() {
        System.out.println("y");
    }
}

a) Não compila.

b) Imprime x, y.

c) Imprime y, x.

d) Imprime x.

e) Imprime y.


2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        x();
    }

    static void x() {
        System.out.println("x");
        y();
    }

    static void y() {
        System.out.println("y");
    }
}

a) Não compila.

b) Imprime x, y.

c) Imprime y, x.

d) Imprime x.

e) Imprime y.


3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    void y() {
        this.z();
    }

    static void z() {
        System.out.println("z");
    }
}

class A {
    public static void main(String[] args) {
        new A().x();
    }

    static void x() {
        new B().y();
    }
}

a) Não compila ao tentar invocar y.

b) Não compila ao tentar invocar z.

c) Não compila ao tentar invocar x.

d) Compila e imprime z.


4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    static void x() {
        System.out.println("x");
    }

    static void y() {
        System.out.println("y");
    }
}

class A extends B {
    public static void main(String[] args) {
        this.x();
        A.y();
    }
}

a) Não compila, erro ao invocar x.

b) Imprime x, y.

c) Não compila, erro ao invocar y.


5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    static void x() {
        System.out.println("x");
    }

    static void y() {
        System.out.println("y");
    }
}

class A extends B {
    public static void main(String[] args) {
        x();
        A.y();
    }
}

a) Não compila, erro ao invocar x.

b) Imprime x, y.

c) Não compila, erro ao invocar y.


8.3 Exercícios


1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int x = b(15);
        System.out.println(x);
        System.out.println(15);
        System.out.println(15.0);
    }

    static int b(int i) { return i; }
    static double b(int i) { return i; }
}

a) Não compila.

b) Compila e imprime 15, 15, 15.

c) Compila e imprime 15, 15, 15.0.

d) Compila e imprime 15, 15.0, 15.0.


2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int x = b(15);
        System.out.println(x);
        System.out.println(15);
        System.out.println(15.0);
    }

    static int b(int i) { return i; }
    static double b(double i) { return i; }
}

a) Não compila.

b) Compila e imprime 15, 15, 15.

c) Compila e imprime 15, 15, 15.0.

d) Compila e imprime 15, 15.0, 15.0.


3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        System.out.println("[]");
    }

    public static void main(String... args) {
        System.out.println("...");
    }
}

a) Não compila.

b) Compila e imprime "[]".

c) Compila e imprime "...".

d) Compila e dá exception.


4 = Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B{}
class C{}
class D extends B{}
class A {
    int a(D d) { return 1; }
    int a(C c) { return 2; }
    int a(B b) { return 3; }
    int a(A a) { return 4; }

    public static void main(String[] args) {
        System.out.println(new A().a(new D()));
    }
}

a) Não compila.

b) Compila e imprime 1.

c) Compila e imprime 2.

d) Compila e imprime 3.

e) Compila e imprime 4.


5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B{}
class C{}
class D extends B{}
class A {
    static int a(D d) { return 1; }
    static int a(C c) { return 2; }
    static int a(B b) { return 3; }
    static int a(A a) { return 4; }

    public static void main(String[] args) {
        System.out.println(a(new D()));
    }
}

a) Não compila.

b) Compila e imprime 1.

c) Compila e imprime 2.

d) Compila e imprime 3.

e) Compila e imprime 4.


6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B{}
class C{}
class D extends B{}
class A {
    static int a(D d) { return 1; }
    static int a(C c) { return 2; }
    static int a(B b) { return 3; }
    static int a(A a) { return 4; }

    public static void main(String[] args) {
        System.out.println(a(new D()));
    }
}

a) Não compila.

b) Compila e imprime 1.

c) Compila e imprime 2.

d) Compila e imprime 3.

e) Compila e imprime 4.


7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B{}
class C{}
class D extends B{}
class A {
    static int a(D d, B b) { return 1; }
    static int a(C c, C c) { return 2; }
    static int a(B b, B b) { return 3; }
    static int a(A a, A a) { return 4; }

    public static void main(String[] args) {
        System.out.println(a(new D(), new D()));
    }
}

a) Não compila.

b) Compila e imprime 1.

c) Compila e imprime 2.

d) Compila e imprime 3.

e) Compila e imprime 4.


8 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B{}
class C{}
class D extends B{}
class A {
    static int a(D d, B b2) { return 1; }
    static int a(C c, C c2) { return 2; }
    static int a(B b, B b2) { return 3; }
    static int a(A a, A a2) { return 4; }

    public static void main(String[] args) {
        System.out.println(a(new D(), new D()));
    }
}

a) Não compila.

b) Compila e imprime 1.

c) Compila e imprime 2.

d) Compila e imprime 3.

e) Compila e imprime 4.


8.4 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
   final String n;
   
   A() {
      a();
      n = "learning";
   }
   
   void a() {
      System.out.println("test");
   }
}

class B extends A {
   void a() {
      System.out.println(n.length());
   }

   public static void main(String[] args) {
      new B();
   }
}

a) Não compila.
b) Compila e imprime "test".
c) Compila e imprime length.
d) Compila e dá exception.
e) Compila e não imprime nada.

8.5 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B { 
   B() { 
      this(1); 
   } 
   B(int i) { 
      this(); 
   } 
}

class A {
   public static void main(String[] args) {
      new B();
   }
}

a) Não compila.
b) Compila e joga exception.
c) Compila e não imprime nada.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B() { 
   B(A a) {} 
   B() {} 
}

class C() { 
   C(B b) {} 
   C() {} 
}

class A {
   public static void main(String[] args) {
      new A(); 
      new B(); 
      new C();
   }
}

a) Não compila ao invocar o construtor de A.
b) Não compila ao invocar o construtor de B.
c) Não compila ao invocar o construtor de C.
d) Não compila na definição das classes B e C.
e) Compila e joga exception.
f) Compila e não imprime nada.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B { 
   B(A a) {} 
   B() {} 
}

class C { 
   C(B b) {} 
   C() {} 
}

class A {
   public static void main(String[] args) {
      new A(); 
      new B(); 
      new C();
   }
}

a) Não compila ao invocar o construtor de A.
b) Não compila ao invocar o construtor de B.
c) Não compila ao invocar o construtor de C.
d) Não compila na definição das classes B e C.
e) Compila e joga exception.
f) Compila e não imprime nada.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B { 
   B(A a) {} 
   B() {} 
}

class C { 
   C(B b) {} 
   C() {} 
}

class A {
   public static void main(String[] args) {
      new C(new B(new A()));
   }
}

a) Não compila ao invocar o construtor de A.
b) Não compila ao invocar o construtor de B.
c) Não compila ao invocar o construtor de C.
d) Não compila na definição das classes B e C.
e) Compila e joga exception.
f) Compila e não imprime nada.

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B { 
   B(A a) {
      new C(); 
   } 
   B() { 
      new C(this);
   } 
}

class C { 
   C(B b) {
      new B(new A());
   } 
   C() {
      new B();
   } 
}

class A {
   public static void main(String[] args) {
      new C(new B(new A()));
   }
}

a) Não compila ao invocar o construtor de A.
b) Não compila ao invocar o construtor de B.
c) Não compila ao invocar o construtor de C.
d) Não compila na definição das classes B e C.
e) Compila e joga exception.
f) Compila e não imprime nada.

8.6 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o Test, com os arquivos a seguir nos diretórios adequados:

import model.Client;

class Test {
   public static void main(String[] args) {
      new Client("guilherme").print();
   }
}

package model;

public class Client {
   private String name;

   public Client(String name) {
      this.name = name;
   }

   public void print() {
      System.out.println(name);
   }
}

a) Não compila: erro na classe Teste.
b) Não compila: erro na classe Client.
c) Erro de execução: método main.
d) Roda e imprime “Guilherme”.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
   private static int a(int b) {
      return b(b) - 1;
   }

   private static int b(int b) {
      return b - 1;
   }

   public static void main(String[] args) {
      System.out.println(new A().a(5));
   }
}

a) Não compila.
b) Compila e imprime 3.
c) Compila e dá erro de execução.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
   private public int a(int b) {
      return b(b) - 1;
   }

   private static int b(int b) {
      return b - 1;
   }

   public static void main(String[] args) {
      System.out.println(new A().a(5));
   }
}

a) Não compila nas invocações de métodos.
b) Não compila na declaração de variáveis e métodos.
c) Compila e imprime 3.
d) Compila e dá erro.

4 - Escolha a opção adequada ao tentar compilar e rodar os arquivos a seguir, cada um em seu diretório adequado:

package a;
import b.*;

public class A extends B {
   protected int a(String s) {
      return 2;
   }
}

package b;

public class B {
   public int a(Object s) {
      return 1;
   }
}

import a.*;
import b.*;

class Test {
   public static void main(String[] args) {
      System.out.println(new A().a("a"));
   }
}

a) Não compila.
b) Imprime 1.
c) Imprime 2.
d) Erro em execução.

5 - Escolha a opção adequada ao tentar compilar e rodar os arquivos a seguir, cada um em seu diretório adequado:

package a;
import b.*;

public class A extends B {
   protected int a(String s) {
      return 2;
   }
}

package b;

public class B {
   public int a(Object s) {
      return 1;
   }
}

import a.*;
import b.*;

class C {
   public static void main(String[] args) {
      System.out.println(new A().a("a"));
   }
}

a) Não compila.
b) Imprime 1.
c) Imprime 2.
d) Erro em execução.

6 - Escolha a opção adequada ao tentar compilar e rodar os arquivos a seguir, cada um em seu diretório adequado:

package a;
import b.*;

public class A extends B {
   protected int a(String s) {
      return 2;
   }
}

package b;

public class B {
   default int a(Object s) {
      return 1;
   }
}

import a.*;
import b.*;

class C {
   public static void main(String[] args) {
      System.out.println(new A().a("a"));
   }
}

a) Não compila.
b) Imprime 1.
c) Imprime 2.
d) Erro em execução.

7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
   static int bs = 0;
   final int b = ++bs;

   private B() {}

   static B b() {
      return new B();
   }
}

class A {
   public static void main(String[] args) {
      System.out.println(B.b().b);
   }
}

a) Não compila.
b) Compila e imprime 1.
c) Compila e imprime 0.
d) Compila e dá erro de execução.

8.7 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B{
    private int b;
    public int getB() { return b; }
    public void setB(int b) { this.b= b; }
}

class A {
    public static void main(String[] args) {
        new B().setB(5);
        System.out.println(new B().getB());
    }
}

a) Não compila.  
b) Compila e imprime 0.  
c) Compila e imprime 5.


2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    private int b;
    public int getB() { return b; }
    public void setB(int b) { this.b= b; }
}

class A {
    public static void main(String[] args) {
        B b = new B();
        b.setB(5);
        System.out.println(b.getB());
    }
}

a) Não compila.  
b) Compila e imprime 0.  
c) Compila e imprime 5.


3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:
class B{
    private int b;
    public int getB() { return b; }
    public void setB(int b) { b= b; }
}

class A {
    public static void main(String[] args) {
        B b = new B();
        b.setB(5);
        System.out.println(b.getB());
    }
}

a) Não compila.  
b) Compila e imprime 0.  
c) Compila e imprime 5.


4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B{
    int b;
    public void setB(int b) { b= b; }
}

class A {
    public static void main(String[] args) {
        B b = new B();
        b.setB(5);
        System.out.println(b.b);
    }
}

a) Não compila, pois não é possível ter setter sem getter.  
b) Compila e imprime 0.  
c) Compila e imprime 5.


5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B{
    private final int b;
    B(int b) { this.b = b;}
    public int getB() { return b; }
    public void setB(int b) { b= b; }
}

class A {
    public static void main(String[] args) {
        B b = new B(10);
        b.setB(5);
        System.out.println(b.getB());
    }
}

a) Não compila.  
b) Compila e imprime 0.  
c) Compila e imprime 5.  
d) Compila e imprime 10.

8.8 Exercícios

1 -  Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
  public static void main(String[] args) {
    int i = 150;
    i = ++s(i);
    System.out.println(i);
  }

  static int s(int i) {
    return ++i;
  }
}

a) Não compila.  
b) Compila e imprime 150.  
c) Compila e imprime 151.  
d) Compila e imprime 152.  

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
  public static void main(String[] args) {
    int[] i = {150, 151};
    i = s(i);
    System.out.println(i[1]);
  }

  static int[] s(int[] i) {
    int[] j = {i[0], i[1]};
    i[1]++;
    return j;
  }
}

a) Não compila.  
b) Compila e imprime 150.  
c) Compila e imprime 151.  
d) Compila e imprime 152.  
e) Compila e imprime 153.


9.1 Exercícios


1 - Compila?

class A {
    public void method(long l) {
    }
}

class B extends A {
    protected void method(int i) {
    }
}

2 - Compila? 

import java.io.*;

class Vehicle {
    protected void turnon() throws IOException {
    }
}

class Car extends Vehicle {
    public void turnon() throws FileNotFoundException {
    }
}


3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B extends C {
    int m(int a) {
        return 1;
    }
}

class C extends A {
    int m(double b) {
        return 3;
    }
}

class A extends B {
    int m(String c) {
        return 3;
    }

    public static void main(String[] args) {
        System.out.println(new C().m(3));
    }
}

a) O código não compila.
b) Compila e imprime 1.
c) Compila e imprime 2.
d) Compila e imprime 3.
e) Compila e imprime 1, 2, 3.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    int m(int a) {
        return 1;
    }
}

class C {
    int m(double b) {
        return 2;
    }
}

class A extends B, C {
    public static void main(String[] args) {
        System.out.println(new C().m(3));
    }
}

a) O código não compila.
b) Compila e imprime 1.
c) Compila e imprime 2.
d) Compila e imprime 1, 2.

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    private B() {
    }

    static B B(String s) {
        return new B();
    }
}

class A {
    public static void main(String[] args) {
        B b = B.B("t");
    }
}

a) Não compila.
b) Compila e imprime “t”.
c) Compila e não imprime nada.
d) Compila e joga uma exception.

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    private B() {
    }

    static B B(String s) {
        return new B();
    }
}

class A extends B {
    public static void main(String[] args) {
        B b = B.B("t");
    }
}

Qual a saída esperada?
a) Não compila.
b) Compila e imprime “t”.
c) Compila e não imprime nada.
d) Compila e joga uma exception.

7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    private String s;

    protected B() {
    }

    static A B(String s) {
        return new A();
    }
}

class A extends B {
    A(String s) {
        this.s = s;
    }

    public static void main(String[] args) {
        B b = A.B("t");
        System.out.println(b.s);
    }
}

a) Não compila.
b) Compila e imprime “t”.
c) Compila e não imprime nada.
d) Compila e joga uma exception.

8 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    protected String s;

    protected B() {
    }

    static A B(String s) {
        return new A(s);
    }
}

class A extends B {
    A(String s) {
        this.s = s;
    }

    public static void main(String[] args) {
        A b = A.B("t");
        System.out.println(b.s);
    }
}

a) Não compila.
b) Compila e imprime “t”.
c) Compila e não imprime nada.
d) Compila e joga uma exception.


9.2 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
}

class C extends B {
}

class A {
    public static void main(String[] args) {
        new C().x();
    }
}

a) Não compila.  
b) Compila e imprime ‘b‘.  
c) Compila e imprime ‘c‘.  
d) Compila e não imprime nada.  
e) Compila e dá exception.  
f) Compila e entra em loop.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

import java.io.*;

class B {
}

class C extends B {
}

class A {
    public static void main(String[] args) throws IOException {
        new C().x();
    }
}

a) Não compila.  
b) Compila e imprime ‘b‘.  
c) Compila e imprime ‘c‘.  
d) Compila e não imprime nada.  
e) Compila e dá exception.  
f) Compila e entra em loop.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

import java.io.*;

class B {
}

class C extends B {
}

class A {
    public static void main(String[] args) throws IOException {
        new C().x(3.2);
    }
}

a) Não compila.  
b) Compila e imprime ‘b‘.  
c) Compila e imprime ‘c‘.  
d) Compila e não imprime nada.  
e) Compila e dá exception.  
f) Compila e entra em loop.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

import java.io.*;

class B {
}

class C {
}

class A {
    public static void main(String[] args) throws IOException {
        new C().x(3.2);
    }
}

a) Não compila.  
b) Compila e imprime ‘b‘.  
c) Compila e imprime ‘c‘.  
d) Compila e não imprime nada.  
e) Compila e dá exception.  
f) Compila e entra em loop.

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

import java.io.*;

interface B {
}

class C implements B {
}

class A {
    public static void main(String[] args) throws IOException {
        new C().x(3);
    }
}

a) Não compila.  
b) Compila e imprime ‘b‘.  
c) Compila e imprime ‘c‘.  
d) Compila e não imprime nada.  
e) Compila e dá exception.  
f) Compila e entra em loop.

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

import java.io.*;

class B {
}

abstract class C extends B {
}

abstract class D extends C {
}

class E extends D {
}

class A {
    public static void main(String[] args) throws IOException {
        new E().x(32);
    }
}

a) Não compila.  
b) Compila e imprime ‘b‘.  
c) Compila e imprime ‘c‘.  
d) Compila e imprime ‘d‘.  
e) Compila e não imprime nada.  
f) Compila e dá exception.  
g) Compila e entra em loop.

9.3 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class D extends C {
    void x() { System.out.println(1); }
}

class C extends B {
    void x() { System.out.println(2); }
}

class B {
    void x() { System.out.println(3); }

    void y(B b) {
        b.x();
    }

    void y(C c) {
        c.x();
    }

    void y(D d) {
        d.x();
    }
}

class A {
    public static void main(String[] args) {
        new B().y(new C());
    }
}

a) Não compila.  
b) Compila e imprime 1.  
c) Compila e imprime 2.  
d) Compila e imprime 3.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class D extends C {
    void x() { System.out.println(1); }
}

class C extends B {
    void x() { System.out.println(2); }
}

class B {
    void x() { System.out.println(3); }

    void y(B b) {
        b.x();
    }

    void y(C c) {
        c.x();
    }

    void y(D d) {
        d.x();
    }
}

class A {
    public static void main(String[] args) {
        new D().y(new C());
    }
}

a) Não compila.  
b) Compila e imprime 1.  
c) Compila e imprime 2.  
d) Compila e imprime 3.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class D extends C {
    void x() { System.out.println(1); }

    void y(C b) {
        x();
    }
}

class C extends B {
    void x() { System.out.println(2); }
}

class B {
    void x() { System.out.println(3); }

    void y(B b) {
        b.x();
    }
}

class A {
    public static void main(String[] args) {
        new D().y(new C());
    }
}

a) Não compila.  
b) Compila e imprime 1.  
c) Compila e imprime 2.  
d) Compila e imprime 3.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:


class D extends C {
    void x() { System.out.println(1); }

    void y(C b) {
        x();
    }
}

class C extends B {
    void x() { System.out.println(2); }
}

class B {
    void x() { System.out.println(3); }

    void y(B b) {
        b.x();
    }
}

class A {
    public static void main(String[] args) {
        new D().y(new D());
    }
}

a) Não compila.  
b) Compila e imprime 1.  
c) Compila e imprime 2.  
d) Compila e imprime 3.

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

package savings;

public class SavingsAccount extends model.Account {
    void close() {
        System.out.println("closing savings");
    }
}

package model;

public class Account {
    void close() {
        System.out.println("closing base");
    }
}

package code;

class A {
    public static void main(String[] args) {
        new Account().close();
    }
}

a) Não compila.  
b) Compila e roda jogando exception.  
c) Compila e roda, imprimindo ‘closing savings‘.  
d) Compila e roda, imprimindo ‘closing base‘.

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

package savings;

public class SavingsAccount extends model.Account {
    void close() {
        System.out.println("closing savings");
    }
}

package model;

public class Account {
    public void close() {
        System.out.println("closing base");
    }
}

package code;

class A {
    public static void main(String[] args) {
        new Account().close();
    }
}

a) Não compila.  
b) Compila e roda jogando exception.  
c) Compila e roda, imprimindo ‘closing savings‘.  
d) Compila e roda, imprimindo ‘closing base‘.

7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

package savings;

public class SavingsAccount extends model.Account {
    void close() {
        System.out.println("closing savings");
    }
}

package model;

public class Account {
    protected void close() {
        System.out.println("closing base");
    }
}

package code;

class A {
    public static void main(String[] args) {
        new Account().close();
    }
}

a) Não compila.  
b) Compila e roda jogando exception.  
c) Compila e roda, imprimindo ‘closing savings‘.  
d) Compila e roda, imprimindo ‘closing base‘.

8 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

package savings;

public class SavingsAccount extends model.Account {
    public void close() {
        System.out.println("closing savings");
    }
}

package model;

public class Account {
    public void close() {
        System.out.println("closing base");
    }
}

package code;

class A {
    public static void main(String[] args) {
        Account c = new SavingsAccount();
        c.close();
    }
}

a) Não compila.  
b) Compila e roda jogando exception.  
c) Compila e roda, imprimindo ‘closing savings‘.  
d) Compila e roda, imprimindo ‘closing base‘.

9 - O que acontece com o código a seguir?

interface Vehicle {
    int getSpeed();
    void turnon();
}

abstract class Car implements Vehicle {
    public void turnon() {
        System.out.println("on!");
    }
}

class ConcreteCar extends Car implements Vehicle {
    public int getSpeed() {
        return 1;
    }
}

a) Não compila.  
b) Compila e roda, imprimindo 'on!'.  
c) Compila e roda, mas não imprime nada.  
d) Compila, mas gera uma exception ao rodar.


9.4 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

interface Z {}
interface W {};
interface Y extends Z, W {}
class B {}
class C extends B implements Y {}
class D extends B implements Z, W {}
class E extends C {}
class A {
    public static void main(String[] args) {
        B b = new C();
    }
}

a) Não compila na definição das classes e interfaces.  
b) Não compila dentro do método main.  
c) Compila e roda sem exception.  
d) Compila e roda dando exception.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

interface Z {}
interface W {}
interface Y extends Z, W {}
class B {}
class C extends B implements Y {}
class D extends B implements Z, W {}
class E extends C {}
class A {
    public static void main(String[] args) {
        C c = (C) new B();
    }
}

a) Não compila na definição das classes e interfaces.  
b) Não compila dentro do método main.  
c) Compila e roda sem exception.  
d) Compila e roda dando exception.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

interface Z {}
interface W {}
interface Y extends Z, W {}
class B {}
class C extends B implements Y {}
class D extends B implements Z, W {}
class E extends C {}
class A {
    public static void main(String[] args) {
        Y y = new D();
    }
}

a) Não compila na definição das classes e interfaces.  
b) Não compila dentro do método main.  
c) Compila e roda sem exception.  
d) Compila e roda dando exception.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

interface Z {}
interface W {}
interface Y extends Z, W {}
class B {}
class C extends B implements Y {}
class D extends B implements Z, W {}
class E extends C {}
class A {
    public static void main(String[] args) {
        Y y = (Y) new D();
    }
}

a) Não compila na definição das classes e interfaces.  
b) Não compila dentro do método main.  
c) Compila e roda sem exception.  
d) Compila e roda dando exception.

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

interface Z {}
interface W {}
interface Y extends Z, W {}
class B {}
class C extends B implements Y {}
class D extends B implements Z, W {}
class E extends C {}
class A {
    public static void main(String[] args) {
        Z z = (Z) (B) new D();
    }
}

a) Não compila na definição das classes e interfaces.  
b) Não compila dentro do método main.  
c) Compila e roda sem exception.  
d) Compila e roda dando exception.

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

interface Z {}
interface W {}
interface Y extends Z, W {}
class B {}
class C extends B implements Y {}
class D extends B implements Z, W {}
class E extends C {}
class A {
    public static void main(String[] args) {
        Y y = (Y) new A();
    }
}

a) Não compila na definição das classes e interfaces.  
b) Não compila dentro do método main.  
c) Compila e roda sem exception.  
d) Compila e roda dando exception.

7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

interface Z {}
interface W {}
interface Y extends Z, W {}
class B {}
class C extends B implements Y {}
class D extends B implements Z, W {}
class E extends C {}
class A {
    public static void main(String[] args) {
        D d = (D) (Y) (B) new D();
    }
}

a) Não compila na definição das classes e interfaces.  
b) Não compila dentro do método main.  
c) Compila e roda.  

8 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

interface Z {}
interface W {}
interface Y extends Z, W {}
class B {}
class C extends B implements Y {}
class D extends B implements Z, W {}
class E extends C {}
class A {
    public static void main(String[] args) {
        System.out.println(((B) (Z) (W) (Y) new D()) instanceof D);
    }
}

a) Não compila na definição das classes e interfaces.  
b) Não compila dentro do método main.  
c) Compila e imprime true.  
d) Compila e imprime false.

9 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

interface Z {}
interface W {}
interface Y extends Z, W {}
class B {}
class C extends B implements Y {}
class D extends B implements Z, W {}
class E extends C {}
class A {
    public static void main(String[] args) {
        System.out.println(((B) (Z) (W) (Y) new D()) instanceof D);
    }
}

a) Não compila na definição das classes e interfaces.  
b) Não compila dentro do método main.  
c) Compila e imprime true.  
d) Compila e imprime false.  
e) Compila mas lança exception.


9.5 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    int x = 1;
}

class A extends B {
    static int x = 2;
    
    public static void main(String[] args) {
        System.out.println(x);
    }
}

a) Não compila.
b) Compila e imprime 1.
c) Compila e imprime 2.
d) Compila e dá exception.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    int x = 1;
}

class A extends B {
    static int x = 2;
    
    public static void main(String[] args) {
        System.out.println(this.x);
    }
}

a) Não compila.
b) Compila e imprime 1.
c) Compila e imprime 2.
d) Compila e dá exception.


3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    int x = 1;
}

class A extends B {
    static int x = 2;
    
    public static void main(String[] args) {
        System.out.println(super.x);
    }
}

a) Não compila.
b) Compila e imprime 1.
c) Compila e imprime 2.
d) Compila e dá exception.


4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    int x = 1;
}

class A extends B {
    static int x = 2;
    
    public static void main(String[] args) {
        System.out.println(new A().super.x);
    }
}

a) Não compila.
b) Compila e imprime 1.
c) Compila e imprime 2.
d) Compila e dá exception.


5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    void B() {
    }
    
    void B(String s) {
        this();
        this(s);
    }
}

class A {
    public static void main(String[] args) {
        B b = new B();
    }
}

a) Não compila.
b) Compila e dá exception.
c) Compila e não imprime nada.
d) Compila e entra em loop infinito.


6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    B() {
    }
    
    B(String s) {
        this();
        this(s);
    }
}

class A {
    public static void main(String[] args) {
        B b = new B();
    }
}

a) Não compila.
b) Compila e dá exception.
c) Compila e não imprime nada.
d) Compila e entra em loop infinito.


7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    B() {
    }
    
    B(String s) {
        this();
    }
}

class A {
    public static void main(String[] args) {
        B b = new B();
    }
}

a) Não compila.
b) Compila e dá exception.
c) Compila e não imprime nada.
d) Compila e entra em loop infinito.


8 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    B() {
    }
    
    B(String s) {
        this();
    }
}

class A {
    public static void main(String[] args) {
        String s = null;
        B b = new B(s);
    }
}

a) Não compila.
b) Compila e dá exception.
c) Compila e não imprime nada.
d) Compila e entra em loop infinito.


9 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    int x() { return y(); }
    
    int y() { return 3; }
}

class C extends B {
    C() {
        this(x());
    }
    
    C(int i) {
        System.out.println(i);
    }
    
    int y() { return 2; }
}

class A {
    public static void main(String[] args) {
        new C();
    }
}

a) Não compila.
b) Compila e imprime ‘2‘.
c) Compila e imprime ‘3‘.


10 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class B {
    int x() { return y(); }
    
    int y() { return 3; }
}

class C extends B {
    C() {
        super();
        z(x());
    }
    
    void z(int i) {
        System.out.println(i);
    }
    
    int y() { return 2; }
}

class A {
    public static void main(String[] args) {
        new C();
    }
}

a) Não compila.
b) Compila e imprime ‘2‘.
c) Compila e imprime ‘3‘.

9.6 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

abstract class B {
    void x() {
        System.out.println(y());
    }

    abstract int y();
}

class C extends B {
    int y() {
        return 1;
    }
}

class D extends C {
    int y() {
        return 2;
    }
}

class A {
    public static void main(String[] args) {
        D d = (D) (C) new D();
        d.x();
    }
}

a) Não compila.  
b) Compila e imprime ‘1‘.  
c) Compila e imprime ‘2‘.  
d) Compila e roda com exception.


2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

abstract class B {
    abstract void x() {
        System.out.println(y());
    }

    abstract int y();
}

class C extends B {
    int y() {
        return 1;
    }
}

class D extends C {
    int y() {
        return 2;
    }
}

class A {
    public static void main(String[] args) {
        D d = (D) (C) new D();
        d.x();
    }
}

a) Não compila.  
b) Compila e imprime ‘1‘.  
c) Compila e imprime ‘2‘.  
d) Compila e roda com exception.


3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

abstract class B {
    void x() {
        System.out.println(y());
    }

    abstract int y();
}

abstract class C extends B {
    abstract int y();
}

class D extends C {
    int y() {
        return 1;
    }
}

class A {
    public static void main(String[] args) {
        D d = (D) (C) new D();
        d.x();
    }
}

a) Não compila.  
b) Compila e imprime ‘1‘.  
c) Compila e imprime ‘2‘.  
d) Compila e roda com exception.


4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

abstract class B {
    void x() {
        System.out.println(y());
    }

    int y() {
        return 2;
    }
}

abstract class C extends B {
    abstract int y();
}

class D extends C {
    int y() {
        return 1;
    }
}

class A {
    public static void main(String[] args) {
        D d = (D) (C) new D();
        d.x();
    }
}

a) Não compila.  
b) Compila e imprime ‘1‘.  
c) Compila e imprime ‘2‘.  
d) Compila e roda com exception.


5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

abstract class B {
    void x() {
        System.out.println(y());
    }

    final int y() {
        return 2;
    }
}

abstract class C extends B {
    int y() {
        return 3;
    }
}

class D extends C {
    int y() {
        return 1;
    }
}

class A {
    public static void main(String[] args) {
        D d = (D) (C) new D();
        d.x();
    }
}

a) Não compila.  
b) Compila e imprime ‘1‘.  
c) Compila e imprime ‘2‘.  
d) Compila e roda with exception.


6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

abstract class B {
    void x() {
        System.out.println(y());
    }

    Object y() {
        return "a";
    }
}

abstract class C extends B {
    abstract String y();
}

class D extends C {
    String y() {
        return "b";
    }
}

class A {
    public static void main(String[] args) {
        D d = (D) (C) new D();
        d.x();
    }
}

a) Não compila.  
b) Compila e imprime ‘a‘.  
c) Compila e imprime ‘b‘.  
d) Compila e roda with exception.


10.1 Exercícios

1 - Dentre as classes a seguir qual delas não é checked?
a) java.io.IOException
b) java.sql.SQLException
c) java.lang.Exception
d) java.lang.IndexOutOfBoundsException
e) java.io.FileNotFoundException

10.2 Exercícios

1 - Exception é um mecanismo para...
a) tratar entrada de dados do usuário.
b) que você pode usar para determinar o que fazer quando algo inesperado acontece.
c) que a VM usa para fechar o programa caso algo inesperado aconteça.
d) controlar o fluxo da aplicação.
e) separar o tratamento de erros da lógica principal.

2 - De que maneira a API de exceptions pode ajudar a melhorar o código de
seu programa?
Escolha 2 opções:
a) Permitindo separar o tratamento de erro da lógica do programa.
b) Permitindo tratar o erro no mesmo ponto onde ele ocorre.
c) Permitindo estender as classes que já existem e criar novas exceptions.
d) Disponibilizando várias classes com todas as exceptions possíveis
prontas.
e) Aumentando a segurança da aplicação disponibilizando os erros nos
logs.

10.3 Exercícios


1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String name;
        try {
            name.toLowerCase();
            System.out.println("a");
        } catch(NullPointerException ex) {
            System.out.println("b");
        }
        System.out.println("c");
    }
}

a) Não compila.  
b) Compila e, ao rodar, imprime “abc”.  
c) Compila e, ao rodar, imprime “bc”.  
d) Compila e, ao rodar, imprime “a”.  
e) Compila e, ao rodar, imprime “b”.

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String name = null;
        try {
            name.toLowerCase();
            System.out.println("a");
        } catch(NullPointerException ex) {
            System.out.println("b");
        }
        System.out.println("c");
    }
}

a) Não compila.  
b) Compila e, ao rodar, imprime “abc”.  
c) Compila e, ao rodar, imprime “bc”.  
d) Compila e, ao rodar, imprime “a”.  
e) Compila e, ao rodar, imprime “b”.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        String name = null;
        try {
            name.toLowerCase();
            System.out.println("a");
        } catch(NullPointerException ex) {
            System.out.println("b");
        } finally {
            System.out.println("c");
        }
        System.out.println("d");
    }
}

a) Não compila.  
b) Compila e, ao rodar, imprime “abcd”.  
c) Compila e, ao rodar, imprime “bcd”.  
d) Compila e, ao rodar, imprime “ac”.  
e) Compila e, ao rodar, imprime “bc”.  
f) Compila e, ao rodar, imprime “ad”.  
g) Compila e, ao rodar, imprime “bd”.

10.4

1 - Qual classe podemos colocar no código a seguir para que ele compile?

import java.io.*;

class X {
    InputStream y() throws FileNotFoundException {
        return new FileInputStream("a.txt");
    }

    void z() throws FileNotFoundException {
        InputStream is = y();
        is.close();
    }
}

* java.io.IOException * java.sql.SQLException *
java.lang.Exception * java.lang.IndexOutOfBoundsException
* java.io.FileNotFoundException

2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    void m2() {
        System.out.println("e");
        int[][] x = new int[15][20];
        System.out.println("f");
    }

    void m() {
        System.out.println("c");
        m2();
        System.out.println("d");
    }

    public static void main(String[] args) {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime ace, joga uma Exception e imprime db.

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    void m2() {
        System.out.println("e");
        int[] x = new int[15];
        x[20] = 13;
        System.out.println("f");
    }

    void m() {
        System.out.println("c");
        m2();
        System.out.println("d");
    }

    public static void main(String[] args) {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime ace, joga uma Exception e imprime db.

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir,
sem que o arquivo exista?

class A {
    void m2() {
        System.out.println("e");
        new java.io.FileInputStream("a.txt");
        System.out.println("f");
    }

    void m() {
        System.out.println("c");
        m2();
        System.out.println("d");
    }

    public static void main(String[] args) {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime ace, joga uma Exception e imprime db.


5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir,
sem que o arquivo exista?

class A {
    void m2() throws java.io.FileNotFoundException {
        System.out.println("e");
        new java.io.FileInputStream("a.txt");
        System.out.println("f");
    }

    void m() throws java.io.IOException {
        System.out.println("c");
        m2();
        System.out.println("d");
    }

    public static void main(String[] args) throws java.io.FileNotFoundException {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime ace, joga uma Exception e imprime db.

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir,
sem que o arquivo exista?

class A {
    void m2() throws java.io.FileNotFoundException {
        System.out.println("e");
        new java.io.FileInputStream("a.txt");
        System.out.println("f");
    }

    void m() throws java.io.FileNotFoundException {
        System.out.println("c");
        m2();
        System.out.println("d");
    }

    public static void main(String[] args) throws java.io.IOException {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime ace, joga uma Exception e imprime db.

7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir,
sem que o arquivo exista?

class A {
    void m2() throws java.io.FileNotFoundException {
        System.out.println("e");
        new java.io.FileInputStream("a.txt");
        System.out.println("f");
    }

    void m() throws java.io.FileNotFoundException {
        System.out.println("c");
        try {
            m2();
        } catch (java.io.FileNotFoundException ex) {
        }
        System.out.println("d");
    }

    public static void main(String[] args) throws java.io.IOException {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime acedb. 
f) Compila e imprime ace, joga uma Exception e imprime db.


8 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir,
sem que o arquivo exista?

class MyException extends RuntimeException {
}

class A {
    void m2() throws java.io.FileNotFoundException {
        System.out.println("e");
        new MyException();
        System.out.println("f");
    }

    void m() throws java.io.FileNotFoundException {
        System.out.println("c");
        try {
            m2();
        } catch (java.io.FileNotFoundException ex) {
        }
        System.out.println("d");
    }

    public static void main(String[] args) throws java.io.IOException {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime ace, joga uma Exception e imprime db.


9 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir,
sem que o arquivo exista?

class MyException extends RuntimeException {
}

class A {
    void m2() throws java.io.FileNotFoundException {
        System.out.println("e");
        throw new MyException();
        System.out.println("f");
    }

    void m() throws java.io.FileNotFoundException {
        System.out.println("c");
        try {
            m2();
        } catch (java.io.FileNotFoundException ex) {
        }
        System.out.println("d");
    }

    public static void main(String[] args) throws java.io.IOException {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime ace, joga uma Exception e imprime db.


10 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir,
sem que o arquivo exista?

class MyException extends RuntimeException {
}

class A {
    void m2() throws java.io.FileNotFoundException {
        System.out.println("e");
        boolean sim = true;
        if (sim) throw new MyException();
        System.out.println("f");
    }

    void m() throws java.io.FileNotFoundException {
        System.out.println("c");
        try {
            m2();
        } catch (java.io.FileNotFoundException ex) {
        }
        System.out.println("d");
    }

    public static void main(String[] args) throws java.io.IOException {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime ace, joga uma Exception e imprime db.


11 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir,
sem que o arquivo exista?

class MyException extends RuntimeException {
}

class A {
    void m2() throws java.io.FileNotFoundException {
        System.out.println("e");
        boolean sim = true;
        if (sim) throw new MyException();
        System.out.println("f");
    }

    void m() throws java.io.FileNotFoundException {
        System.out.println("c");
        try {
            m2();
        } catch (java.io.FileNotFoundException ex) {
        }
        System.out.println("d");
    }

    public static void main(String[] args) throws java.io.IOException {
        System.out.println("a");
        new A().m();
        System.out.println("b");
    }
}

a) Não compila. 
b) Compila e imprime acefdb. 
c) Compila e imprime ace e joga uma Exception. 
d) Compila e imprime acedb e joga uma Exception. 
e) Compila e imprime ace, joga uma Exception e imprime db.


10.5 Exercícios


1 - Escolha a opção adequada que indica o Throwable que ocorrerá no código a seguir:

class A {
     public static void main(String[] args) {
        main(args);
    }
}

a) IndexOutOfBoundsException  
b) ArrayIndexOutOfBoundsException  
c) NullPointerException  
d) OutOfMemoryError  
e) StackOverflowError  
f) ExceptionInInitializationError


2 - Escolha a opção adequada que indica o Throwable que ocorrerá no código a seguir:

import java.util.*;
class A {
     public static void main(String[] args) {
         ArrayList<String> strings = new ArrayList<String>();
         for(int i=0; i<10; i++)
             for(int j=0; j<10; i++)
                 strings.add("string " + i + " " + j);
         System.out.println(strings.get(99999));
     }
}

a) IndexOutOfBoundsException  
b) ArrayIndexOutOfBoundsException  
c) NullPointerException  
d) OutOfMemoryError  
e) StackOverflowError  
f) ExceptionInInitializationError


11.2 Exercícios


1 - O que acontece ao tentar compilar e executar o código a seguir?

class Test {
    public static void main(String[] args) {
        System.out.print("a");
        System.out.println('b'); // A
        System.out.print(); // B
        System.out.println("c");
    }
}

a) Compila e imprime
ab
c  
b) Compila e imprime
ab
c  
c) Compila e imprime
a
bc  
d) Não compila por erro na linha A  
e) Não compila por erro na linha B


2 - Ao tentar compilar e executar o código a seguir, o que acontece?

public class Test {
    public static void main(String[] args) {
        System.out.print("a");
        System.out.println("b");
        System.out.printf("c");
        System.out.print("d");
        System.out.println("\n");
        System.out.print("e");
    }
}

a) Compila e imprime
ab
cd
e  
b) Compila e imprime
ab
c
d
e  
c) Compila e imprime
ab
cd
e  
d) Não compila


3 - O que acontece ao compilar e executar o código a seguir?

public class Test {
    public static void main(String[] args) {
        System.out.printf("%s", 12); // A
        System.out.printf("%d", new Integer(321)); // B
        System.out.printf("%d", (short)(byte)(double)127); // C
    }
}

a) Erro de compilação na linha B  
b) Erro de compilação nas linhas B e C  
c) Compila e executa normalmente  
d) Erro de compilação na linha C  
e) Erro de compilação na linha A  


4 - Qual dos códigos a seguir NÃO imprime >00012.45<? Escolha 1 alternativa:
a) `System.out.printf(''>%0,8.2f<'', 12.45);`  
b) `System.out.printf(''>%-(8.2f<'', 12.45);`  
c) `System.out.format(''>%0(8.2f<'', 12.45);`  
d) `System.out.format(''>%1$08.2f<'', 12.45);`  
e) `System.out.printf(''>%0,(8.2f<'', 12.45);`


5 - Ao tentar compilar e executar o seguinte código, o que é impresso?

public class Testes {
    public static void main(String[] args) {
        System.out.println(new char[]{'a', 'b', 'c'}); // A
        System.out.println(new byte[]{'a', 'b', 'c'}); // B
        System.out.println("abc"); // C
        System.out.println(new String[]{"abc"}); // D
    }
}

a) Não compila na linha B  
b) Linhas A e C imprimem abc  
c) Linha C imprime abc  
d) Linhas A, C e D imprimem abc  
e) Todas as linhas imprimem abc


11.3 Exercícios

1 - Para aumentar o encapsulamento de uma classe, devemos:

a) Deixar os métodos e atributos privados
b) Deixar os métodos e atributos públicos
c) Deixar os métodos públicos e atributos públicos
d) Deixar os métodos públicos e atributos privados
e) Deixar os métodos privados e atributos públicos


12.1 Exercícios

1 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    public static void main(String[] args) {
        int i = 10;
        m1(i);
    }

    private static void m1(Integer j) {
        System.out.println("go!");
    }
}

a) Erro de compilação  
b) Imprime go!  
c) Imprime 10  
d) Compila mas lança exception  


2 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    static int i;

    public static void main(String[] args) {
        i = Integer.parseInt("10");
        m1(i + 1);
    }

    private static void m1(Integer j) {
        System.out.println(i);
    }
}

a) Erro de compilação  
b) Imprime 11  
c) Imprime 10  
d) Compila mas lança exception  

3 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

class A {
    static int i;

    public static void main(String[] args) {
        i = Integer.valueOf("10");
        m1(i + 1);
    }

    private static void m1(Integer j) {
        System.out.println(j);
    }
}

a) Imprime 10  
b) Erro de compilação  
c) Compila mas lança exception  
d) Imprime 11  

4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

public class Test {
    static long i;

    public static void main(String[] args) {
        i = Integer.valueOf("10", 8); // A
        m1(i); // B
    }

    private static void m1(Integer j) { // C
        System.out.println(j);
    }
}

a) Imprime 10  
b) Erro de compilação na linha A  
c) Erro de compilação na linha B  
d) Erro de compilação na linha C  
e) Compila mas lança exception  

5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

public class Test {
    public static void main(String[] args) {
        int a = Short.parseShort("126"); // A
        short s = Integer.parseInt("23").shortValue(); // B
        double h = Double.valueOf("27").floatValue(); // C
        System.out.println(a + s);
    }
}

a) Imprime 149  
b) Imprime 176  
c) Erro de compilação na linha A  
d) Erro de compilação na linha B  
e) Erro de compilação na linha C  

6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

public class Test {
    public static void main(String[] args) {
        char c = new Character('x').charValue();
        System.out.println(c);
    }
}

a) Imprime x  
b) Imprime 120  
c) Erro de compilação  


7 - Escolha a opção adequada ao tentar compilar e rodar o arquivo a seguir:

public class Test {
    public static void main(String[] args) {
        int a = Integer.parseInt("10", 2);
        int b = a == 10 ? null : 3;
        System.out.println(a + b);
    }
}

a) Imprime 13  
b) Imprime 5  
c) Imprime 10  
d) Erro de compilação  
e) Ao executar lança NullPointerException

13.1 Exercícios

1 - Todas as classes da nova API de datas são:

a) imutáveis
b) mutáveis


2 - A classe que representa um horário sem data é:

a) LocalDateTime
b) TimeZone
c) LocalTime
d) Time


3 - Qual código cria um objeto com a data e hora atual?
a) LocalDate.now();
b) LocalDateTime.now();
c) LocalDateTime.current();
d) new LocalDateTime();


4 - Qual o código que calcula a diferença em dias entre dois LocalDate d1 e d2?

a) ChronoUnit.Days.between(d1,d2);
b) ChronoUnit.DAYS.difference(d1,d2);
c) ChronoUnit.DAYS.between(d1,d2);
d) Period.between(d1,d2);


5. Qual o código que calcula a diferença em dias entre dois LocalDate d1 e d2?

a) ChronoUnit.Days.between(d1,d2);
b) ChronoUnit.DAYS.difference(d1,d2);
c) ChronoUnit.DAYS.between(d1,d2);
d) Period.between(d1,d2);

6 - 
LocalDate birthday = LocalDate.of(1975, 9, 23);
LocalDate today = LocalTime.now();
//code here
   
   System.out.println("You are " + d.getYears() + " years, " + 
                     d.getMonths() + " months, and " + 
                     d.getDays() + " days old.");
   
Qual trecho que, se inserido no local, indicado irá imprimir corretamente a idade?
a) Period d = Period.between(birthday, today);
b) Duration d = Duration.between(birthday, today);
c) Period d = Period.between(today,birthday);
d) Period d = Period.difference(birthday, today);

7 - Qual o trecho de código que converte um objeto Date em um objeto LocalDate?
a) LocalDate.from(d.toInstant());
b) LocalDateTime.from(d.toInstant()).toLocalDate();
c) LocalDateTime.ofInstant(d.toInstant()).toLocalDate();
d) LocalDateTime.ofInstant(d.toInstant(), ZoneId.systemDefault()).toLocalDate();

8 -
System.out.println(YearMonth.now().isSupported(ChronoField.DAY_OF_MONTH));
System.out.println(MonthDay.now().isSupported(ChronoUnit.DAYS));
System.out.println(LocalDate.now().isSupported(ChronoUnit.DAYS));
System.out.println(LocalDateTime.now().isSupported(ChronoField.DAY_OF_MONTH));
Sobre o código, ao tentarmos compilar e executar, o que acontece?
a) Compila e imprime false, true, true, true
b) Compila e imprime true, true, true, true
c) Compila e imprime true, true, false, true
d) Compila, mas lança exception ao executar
e) Não compila

9 -
System.out.println(YearMonth.now().isSupported(ChronoUnit.MONTHS));
System.out.println(YearMonth.now().isSupported(ChronoUnit.DAY_OF_MONTH));
System.out.println(MonthDay.now().isSupported(ChronoField.DAY_OF_MONTH));
System.out.println(LocalDate.now().isSupported(ChronoUnit.DAYS));
System.out.println(LocalDate.now().isSupported(ChronoUnit.YEAR));
System.out.println(LocalDateTime.now().isSupported(ChronoField.HOUR_OF_AMPM));
System.out.println(LocalDateTime.now().isSupported(ChronoField.YEAR));
Sobre o código, ao tentarmos compilar e executar, o que acontece?
a) Compila e imprime true, false, true, true, true, true, true, true
b) Compila e imprime true, true, true, true, true, true, false, true
c) Compila, mas lança exception ao executar
d) Não compila

13.2 Exercícios


1 -

class A {
    public static void main(String[] args) {
        Printer p = null;
        // code here
        p.printMessage();
    }
}

interface Printer {
    void printMessage();
}

Qual código, se incluído na linha indicada, imprime a mensagem “Hello World”?

a) `p = () -> System.out.println("Hello World");`  
b) `p = () => System.out.println("Hello World");`  
c) `p = -> System.out.println("Hello World");`  
d) `p -> System.out.println("Hello World");`


2 - Qual das expressões a seguir é inválida?

a) `Predicate<List> bigger = list -> list.size() > 1000;`  
b) `Predicate<String> startsWithA = s -> s.startsWith("A");`  
c) `Predicate big = list -> list.size() > 100;`  
d) `String name=""; Predicate isEmpty = s -> s.equals("");`


3 - Considere a seguinte interface:

interface Calculator<T> {
    T function(T a, T b);
}

Qual dos códigos a seguir não é válido?

a) `Calculator<Integer> sum = (a,b) -> a + b;`  
b) `Calculator<Integer> multiply = (Integer a, Integer b) -> (int) a * b;`  
c) `Calculator<Integer> subtract = (a,b) -> {return a - b;};`  
d) `Calculator<Integer> divide = (int a, int b) -> {return (Integer) a / b;};`


4 - Escolha a opção adequada ao tentar compilar e rodar o arquivo:

class A {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> System.out.println(i)).start();
        }
    }
}

a) Imprime 0 dez vezes  
b) Imprime os números de 0 a 9  
c) Compila e executa, mas não imprime nada  
d) Erro de compilação  


5 - Escolha a opção adequada ao tentar compilar e rodar o arquivo:

class A {
    int a = 0;

    public static void main(String[] args) {
        new A().method(1, a -> a > 0); // A
    }

    private void method(int a, Predicate<Integer> d) {
        if (d.test(a)) { // B
            System.out.println(a);
        }
    }
}

a) Compila e imprime 0  
b) Compila e imprime 1  
c) Compila e não imprime nada  
d) Não compila por erro na linha A  
e) Não compila por erro na linha B  


6 - Escolha a opção adequada ao tentar compilar e rodar o arquivo:

class A {
    int a = 0;

    public static void main(String[] args) {
        new A().method(1);
    }

    private void method(int a) {
        Predicate<Integer> d = a -> a > 0; // A
        if (d.test(a)) { // B
            System.out.println(a);
        }
    }
}

a) Compila e não imprime nada  
b) Compila e imprime 1  
c) Compila e imprime 0  
d) Não compila por erro na linha A  
e) Não compila por erro na linha B